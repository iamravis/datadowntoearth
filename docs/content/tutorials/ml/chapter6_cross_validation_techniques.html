<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.47">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Ravi Shankar">

<title>chapter6_cross_validation_techniques – Data Down To Earth</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../logo.png" rel="icon" type="image/png">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../styles.css">
<link rel="stylesheet" href="../../content.css">
<meta property="og:title" content="– Data Down To Earth">
<meta property="og:description" content="">
<meta property="og:site_name" content="Data Down To Earth">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Data Down To Earth</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-projects" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Projects</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-projects">    
        <li>
    <a class="dropdown-item" href="../../../projects/dsml_projects.html">
 <span class="dropdown-text">Data Science and ML Projects</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../projects/genai_projects.html">
 <span class="dropdown-text">Generative AI Projects</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-tutorials" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Tutorials</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-tutorials">    
        <li>
    <a class="dropdown-item" href="../../../topics/statistics.html">
 <span class="dropdown-text">Statistics &amp; Probability</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/machine_learning.html">
 <span class="dropdown-text">Machine Learning</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/de.html">
 <span class="dropdown-text">Data Engineering</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/generative_ai.html">
 <span class="dropdown-text">Generative AI</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/public_health.html">
 <span class="dropdown-text">Public Health</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/product_sense.html">
 <span class="dropdown-text">Product Sense</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../../notes/notes.html"> 
<span class="menu-text">Notes</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/iamrsps"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/iamravishankar/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content column-page" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
</div>



<div class="quarto-title-meta column-page">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Ravi Shankar </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="chapter-6.-cross-validation-techniques" class="level1 text-content">
<h1>Chapter 6. Cross-validation Techniques</h1>
<p>Cross-validation techniques are essential for evaluating the performance of machine learning models. They help ensure that the model generalizes well to unseen data and is not overfitting to the training data.</p>
<section id="k-fold-cross-validation" class="level2">
<h2 class="anchored" data-anchor-id="k-fold-cross-validation">6.1. K-fold Cross-validation</h2>
<p>K-fold cross-validation involves splitting the dataset into K equally sized folds. The model is trained on K-1 folds and tested on the remaining fold. This process is repeated K times, with each fold being used exactly once as the test set.</p>
<ul>
<li><p><strong>Steps:</strong></p>
<ol type="1">
<li><p><strong>Split the dataset into K folds:</strong> Divide the data into K subsets of approximately equal size.</p></li>
<li><p><strong>For each fold:</strong></p>
<ul>
<li>Train the model on K-1 folds.</li>
<li>Test the model on the remaining fold.</li>
</ul></li>
<li><p><strong>Compute the average performance:</strong> Calculate the mean of the performance metric (e.g., accuracy, MSE) across all K iterations.</p></li>
</ol></li>
<li><p><strong>Example:</strong> For K=5, the dataset is split into 5 folds, and the process is repeated 5 times, each time using a different fold as the test set.</p></li>
<li><p><strong>Advantages:</strong> Reduces the variance of the performance estimate by averaging over multiple splits. Efficient for large datasets.</p></li>
<li><p><strong>Disadvantages:</strong> More computationally expensive than simple train-test split, especially for large values of K.</p></li>
</ul>
</section>
<section id="stratified-k-fold-cross-validation" class="level2">
<h2 class="anchored" data-anchor-id="stratified-k-fold-cross-validation">6.2. Stratified K-fold Cross-validation</h2>
<p>Stratified K-fold cross-validation ensures that each fold has approximately the same distribution of class labels as the original dataset. It is particularly useful for imbalanced datasets.</p>
<ul>
<li><p><strong>Steps:</strong></p>
<ol type="1">
<li><p><strong>Split the dataset into K folds while maintaining the class distribution:</strong> Ensure each fold has a similar proportion of each class.</p></li>
<li><p><strong>For each fold:</strong></p>
<ul>
<li>Train the model on K-1 stratified folds.</li>
<li>Test the model on the remaining stratified fold.</li>
</ul></li>
<li><p><strong>Compute the average performance:</strong> Calculate the mean of the performance metric across all K iterations.</p></li>
</ol></li>
<li><p><strong>Example:</strong> For a binary classification problem with imbalanced classes, stratified K-fold ensures each fold has a similar ratio of the two classes.</p></li>
<li><p><strong>Advantages:</strong> Provides more reliable performance estimates for imbalanced datasets. Reduces the bias due to imbalanced class distributions.</p></li>
<li><p><strong>Disadvantages:</strong> More complex to implement than regular K-fold cross-validation.</p></li>
</ul>
</section>
<section id="leave-one-out-cross-validation" class="level2">
<h2 class="anchored" data-anchor-id="leave-one-out-cross-validation">6.3. Leave-one-out Cross-validation</h2>
<p>Leave-one-out cross-validation (LOOCV) is an extreme case of K-fold cross-validation where K equals the number of instances in the dataset. Each instance is used once as the test set, and the model is trained on all other instances.</p>
<ul>
<li><p><strong>Steps:</strong></p>
<ol type="1">
<li><strong>For each instance in the dataset:</strong>
<ul>
<li>Use the instance as the test set.</li>
<li>Train the model on the remaining instances.</li>
</ul></li>
<li><strong>Compute the average performance:</strong> Calculate the mean of the performance metric across all iterations.</li>
</ol></li>
<li><p><strong>Example:</strong> For a dataset with 100 instances, LOOCV involves training and testing the model 100 times, each time using a different instance as the test set.</p></li>
<li><p><strong>Advantages:</strong> Uses as much data as possible for training, providing a nearly unbiased estimate of model performance.</p></li>
<li><p><strong>Disadvantages:</strong> Extremely computationally expensive for large datasets. The model may not generalize well due to high variance.</p></li>
</ul>
</section>
<section id="leave-p-out-cross-validation" class="level2">
<h2 class="anchored" data-anchor-id="leave-p-out-cross-validation">6.4. Leave-p-out Cross-validation</h2>
<p>Leave-p-out cross-validation (LPOCV) involves leaving out p instances at a time for the test set and training the model on the remaining data. This process is repeated for all possible combinations of p instances.</p>
<ul>
<li><p><strong>Steps:</strong></p>
<ol type="1">
<li><strong>For each combination of p instances:</strong>
<ul>
<li>Use the p instances as the test set.</li>
<li>Train the model on the remaining instances.</li>
</ul></li>
<li><strong>Compute the average performance:</strong> Calculate the mean of the performance metric across all iterations.</li>
</ol></li>
<li><p><strong>Example:</strong> For p=2 and a dataset with 100 instances, there are <span class="math inline">\({100 \choose 2}\)</span> (4950) possible combinations, and the model is trained and tested 4950 times.</p></li>
<li><p><strong>Advantages:</strong> Provides an unbiased estimate of model performance with high statistical significance.</p></li>
<li><p><strong>Disadvantages:</strong> Computationally infeasible for large p or large datasets due to the combinatorial explosion of possible test sets.</p></li>
</ul>
</section>
<section id="repeated-k-fold-cross-validation" class="level2">
<h2 class="anchored" data-anchor-id="repeated-k-fold-cross-validation">6.5. Repeated K-fold Cross-validation</h2>
<p>Repeated K-fold cross-validation involves repeating the K-fold cross-validation process multiple times with different random splits of the data.</p>
<ul>
<li><p><strong>Steps:</strong></p>
<ol type="1">
<li><strong>Repeat the following process R times:</strong>
<ul>
<li>Split the dataset into K folds.</li>
<li>For each fold:
<ul>
<li>Train the model on K-1 folds.</li>
<li>Test the model on the remaining fold.</li>
</ul></li>
<li>Compute the performance for each iteration.</li>
</ul></li>
<li><strong>Compute the average performance:</strong> Calculate the mean of the performance metric across all K*R iterations.</li>
</ol></li>
<li><p><strong>Example:</strong> For K=5 and R=10, the process involves 50 iterations of training and testing.</p></li>
<li><p><strong>Advantages:</strong> Provides a more robust estimate of model performance by averaging over multiple splits. Reduces the variance of the performance estimate.</p></li>
<li><p><strong>Disadvantages:</strong> More computationally expensive than simple K-fold cross-validation.</p></li>
</ul>
</section>
<section id="nested-cross-validation" class="level2">
<h2 class="anchored" data-anchor-id="nested-cross-validation">6.6. Nested Cross-validation</h2>
<p>Nested cross-validation is used for model selection and hyperparameter tuning. It involves an outer loop for evaluating the model and an inner loop for tuning hyperparameters.</p>
<ul>
<li><p><strong>Steps:</strong></p>
<ol type="1">
<li><strong>Outer loop (model evaluation):</strong>
<ul>
<li>Split the data into K outer folds.</li>
<li>For each outer fold:
<ul>
<li>Use the fold as the test set.</li>
<li><strong>Inner loop (hyperparameter tuning):</strong>
<ul>
<li>Split the remaining data into K inner folds.</li>
<li>For each inner fold:
<ul>
<li>Train the model on K-1 inner folds with different hyperparameters.</li>
<li>Test the model on the remaining inner fold.</li>
</ul></li>
<li>Select the best hyperparameters based on inner loop performance.</li>
</ul></li>
<li>Train the model with the best hyperparameters on the combined inner folds.</li>
<li>Test the model on the outer test fold.</li>
</ul></li>
<li>Compute the performance for each outer iteration.</li>
</ul></li>
<li><strong>Compute the average performance:</strong> Calculate the mean of the performance metric across all outer iterations.</li>
</ol></li>
<li><p><strong>Example:</strong> For K=5 in both outer and inner loops, the process involves 25 iterations of training and testing.</p></li>
<li><p><strong>Advantages:</strong> Provides an unbiased estimate of model performance with hyperparameter tuning. Helps avoid overfitting during model selection.</p></li>
<li><p><strong>Disadvantages:</strong> Highly computationally expensive due to multiple nested cross-validation loops.</p></li>
</ul>
</section>
<section id="time-series-cross-validation" class="level2">
<h2 class="anchored" data-anchor-id="time-series-cross-validation">6.7. Time Series Cross-validation</h2>
<p>Time series cross-validation techniques are designed to respect the temporal order of data. They are used to evaluate models on time-dependent data.</p>
<section id="forward-chaining" class="level3">
<h3 class="anchored" data-anchor-id="forward-chaining">6.7.1. Forward Chaining</h3>
<p>Forward chaining, also known as expanding window or rolling origin, involves training the model on an expanding window of past data and testing it on the subsequent time period.</p>
<ul>
<li><p><strong>Steps:</strong></p>
<ol type="1">
<li><strong>For each time step:</strong>
<ul>
<li>Train the model on data from the start up to time t.</li>
<li>Test the model on data from time t+1.</li>
</ul></li>
<li><strong>Compute the average performance:</strong> Calculate the mean of the performance metric across all iterations.</li>
</ol></li>
<li><p><strong>Example:</strong> For a dataset with 100 time steps, the model is trained on time steps 1 to t and tested on t+1 for each t from 1 to 99.</p></li>
<li><p><strong>Advantages:</strong> Respects the temporal order of data. Suitable for time series forecasting.</p></li>
<li><p><strong>Disadvantages:</strong> Training set size increases with each iteration, which may increase computational cost.</p></li>
</ul>
</section>
<section id="sliding-window" class="level3">
<h3 class="anchored" data-anchor-id="sliding-window">6.7.2. Sliding Window</h3>
<p>Sliding window cross-validation involves training the model on a fixed-size window of past data and testing it on the subsequent time period. The window slides forward in time.</p>
<ul>
<li><p><strong>Steps:</strong></p>
<ol type="1">
<li><strong>For each time step t:</strong>
<ul>
<li>Train the model on data from time t-w to time t, where w is the window size.</li>
<li>Test the model on data from time t+1.</li>
</ul></li>
<li><strong>Compute the average performance:</strong> Calculate the mean of the performance metric across all iterations.</li>
</ol></li>
<li><p><strong>Example:</strong> For a dataset with 100 time steps and a window size of 10, the model is trained on time steps t-9 to t and tested on t+1 for each t from 10 to 99.</p></li>
<li><p><strong>Advantages:</strong> Provides a more consistent training set size. Suitable for non-stationary time series.</p></li>
<li><p><strong>Disadvantages:</strong> May discard valuable data outside the sliding window.</p></li>
</ul>
</section>
<section id="expanding-window" class="level3">
<h3 class="anchored" data-anchor-id="expanding-window">6.7.3. Expanding Window</h3>
<p>Expanding window cross-validation is similar to forward chaining but ensures that the window expands by a fixed number of time steps rather than one at a time.</p>
<ul>
<li><p><strong>Steps:</strong></p>
<ol type="1">
<li><strong>For each expansion step:</strong>
<ul>
<li>Train the model on an expanding window of data.</li>
<li>Test the model on the subsequent time period.</li>
</ul></li>
<li><strong>Compute the average performance:</strong> Calculate the mean of the performance metric across all iterations.</li>
</ol></li>
<li><p><strong>Example:</strong> For a dataset with 100 time steps and an expansion step of 10, the model is trained on time steps 1-10, 1-20, …, 1-90, and tested on the subsequent time steps.</p></li>
<li><p><strong>Advantages:</strong> Uses increasing amounts of data for training, improving the robustness of the model.</p></li>
<li><p><strong>Disadvantages:</strong> Training set size increases significantly, increasing computational cost.</p></li>
</ul>
</section>
</section>
<section id="group-k-fold-cross-validation" class="level2">
<h2 class="anchored" data-anchor-id="group-k-fold-cross-validation">6.8. Group K-fold Cross-validation</h2>
<p>Group K-fold cross-validation is used when there are groups of samples that should not be split across different folds. It ensures that all samples from the same group are either in the training set or the test set.</p>
<ul>
<li><p><strong>Steps:</strong></p>
<ol type="1">
<li><p><strong>Split the dataset into K folds, ensuring groups are not split:</strong> Ensure each fold contains entire groups.</p></li>
<li><p><strong>For each fold:</strong></p>
<ul>
<li>Train the model on K-1 folds.</li>
<li>Test the model on the remaining fold.</li>
</ul></li>
<li><p><strong>Compute the average performance:</strong> Calculate the mean of the performance metric across all K iterations.</p></li>
</ol></li>
<li><p><strong>Example:</strong> For a dataset with patients, where each patient has multiple samples, ensure all samples from the same patient are in the same fold.</p></li>
<li><p><strong>Advantages:</strong> Prevents data leakage by ensuring group integrity. Suitable for datasets with grouped or hierarchical data.</p></li>
<li><p><strong>Disadvantages:</strong> May result in imbalanced folds if groups are of varying sizes.</p></li>
</ul>
</section>
<section id="cross-validation-for-hierarchical-data" class="level2">
<h2 class="anchored" data-anchor-id="cross-validation-for-hierarchical-data">6.9. Cross-validation for Hierarchical Data</h2>
<p>Cross-validation for hierarchical data involves splitting the data at a higher hierarchical level to ensure that lower-level units are not split across different folds.</p>
<ul>
<li><p><strong>Steps:</strong></p>
<ol type="1">
<li><p><strong>Identify hierarchical levels in the data:</strong> For example, schools (higher level) and students (lower level).</p></li>
<li><p><strong>Split the dataset into K folds at the higher level:</strong> Ensure each fold contains entire higher-level units.</p></li>
<li><p><strong>For each fold:</strong></p>
<ul>
<li>Train the model on K-1 folds.</li>
<li>Test the model on the remaining fold.</li>
</ul></li>
<li><p><strong>Compute the average performance:</strong> Calculate the mean of the performance metric across all K iterations.</p></li>
</ol></li>
<li><p><strong>Example:</strong> For a dataset with schools and students, ensure each fold contains entire schools, not individual students.</p></li>
<li><p><strong>Advantages:</strong> Maintains the hierarchical structure of the data, preventing data leakage and ensuring valid performance estimates.</p></li>
<li><p><strong>Disadvantages:</strong> May result in imbalanced folds if higher-level units vary greatly in size.</p></li>
</ul>
</section>
<section id="monte-carlo-cross-validation" class="level2">
<h2 class="anchored" data-anchor-id="monte-carlo-cross-validation">6.10. Monte Carlo Cross-validation</h2>
<p>Monte Carlo cross-validation, also known as random subsampling, involves randomly splitting the dataset into training and test sets multiple times and averaging the performance metrics.</p>
<ul>
<li><p><strong>Steps:</strong></p>
<ol type="1">
<li><strong>Repeat the following process R times:</strong>
<ul>
<li>Randomly split the dataset into a training set and a test set.</li>
<li>Train the model on the training set.</li>
<li>Test the model on the test set.</li>
<li>Compute the performance metric for each iteration.</li>
</ul></li>
<li><strong>Compute the average performance:</strong> Calculate the mean of the performance metric across all R iterations.</li>
</ol></li>
<li><p><strong>Example:</strong> For R=100, the process involves 100 iterations of randomly splitting the dataset, training, and testing the model.</p></li>
<li><p><strong>Advantages:</strong> Provides a robust estimate of model performance by averaging over multiple random splits. Flexible in terms of the size of the training and test sets.</p></li>
<li><p><strong>Disadvantages:</strong> Computationally expensive, especially for large datasets. The randomness of the splits may lead to high variance in the performance estimates.</p></li>
</ul>
<p>By understanding and applying these cross-validation techniques, you can ensure robust and reliable evaluation of your machine learning models, leading to better generalization and performance on unseen data.</p>
</section>
</section>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>