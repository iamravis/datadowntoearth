<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.47">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Ravi Shankar">

<title>causal_inference – Data Down To Earth</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../logo.png" rel="icon" type="image/png">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../../styles.css">
<link rel="stylesheet" href="../../content.css">
<meta property="og:title" content="– Data Down To Earth">
<meta property="og:site_name" content="Data Down To Earth">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Data Down To Earth</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-projects" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Projects</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-projects">    
        <li>
    <a class="dropdown-item" href="../../../projects/dsml_projects.html">
 <span class="dropdown-text">Data Science and ML Projects</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../projects/genai_projects.html">
 <span class="dropdown-text">Generative AI Projects</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-tutorials" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Tutorials</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-tutorials">    
        <li>
    <a class="dropdown-item" href="../../../topics/statistics.html">
 <span class="dropdown-text">Statistics &amp; Probability</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/machine_learning.html">
 <span class="dropdown-text">Machine Learning</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/de.html">
 <span class="dropdown-text">Data Engineering</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/generative_ai.html">
 <span class="dropdown-text">Generative AI</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/public_health.html">
 <span class="dropdown-text">Public Health</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/product_sense.html">
 <span class="dropdown-text">Product Sense</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../../notes/notes.html"> 
<span class="menu-text">Notes</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/iamrsps"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/iamravishankar/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content column-page" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
</div>



<div class="quarto-title-meta column-page">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Ravi Shankar </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="chapter-16-causal-inference" class="level1 text-content">
<h1>Chapter 16: Causal Inference</h1>
<section id="causal-inference-interview-questions-for-data-scientist-role-at-social-media-companies" class="level2">
<h2 class="anchored" data-anchor-id="causal-inference-interview-questions-for-data-scientist-role-at-social-media-companies">Causal Inference Interview Questions for Data Scientist Role at Social Media Companies</h2>
<section id="propensity-score-matching" class="level3">
<h3 class="anchored" data-anchor-id="propensity-score-matching">Propensity Score Matching</h3>
<section id="nearest-neighbor-matching" class="level4">
<h4 class="anchored" data-anchor-id="nearest-neighbor-matching">1. Nearest Neighbor Matching</h4>
<p><strong>Question:</strong> How would you use nearest neighbor matching to estimate the causal effect of a new feature on user engagement on Facebook?</p>
<p><strong>Answer:</strong> Nearest neighbor matching involves pairing treated units (users exposed to the new feature) with control units (users not exposed) that have similar propensity scores. The propensity score is the probability of receiving the treatment given covariates. For example, if we introduce a new feature on Facebook, we would calculate propensity scores for all users based on their characteristics (e.g., age, usage frequency). We then match each treated user to the nearest control user with the closest propensity score, ensuring comparability between groups. The causal effect is estimated by comparing the average engagement between matched pairs. For instance, if the average engagement for treated users is 10% higher than that of their matched controls, we attribute this difference to the new feature.</p>
</section>
<section id="caliper-matching" class="level4">
<h4 class="anchored" data-anchor-id="caliper-matching">2. Caliper Matching</h4>
<p><strong>Question:</strong> What is caliper matching and how does it differ from nearest neighbor matching in a social media context?</p>
<p><strong>Answer:</strong> Caliper matching sets a maximum allowable distance (caliper) between propensity scores of treated and control units. Unlike nearest neighbor matching, which always pairs treated and control units regardless of distance, caliper matching ensures that matches are only made if the propensity score difference is within a specified range. This reduces the risk of poor matches. For instance, when assessing the impact of a new Instagram feature, caliper matching would exclude control users whose propensity scores are too far from treated users, leading to more reliable causal estimates. Suppose we set a caliper of 0.05; only control users within this range of propensity scores from the treated user will be matched.</p>
</section>
<section id="stratification-matching" class="level4">
<h4 class="anchored" data-anchor-id="stratification-matching">3. Stratification Matching</h4>
<p><strong>Question:</strong> How would you apply stratification matching to evaluate the impact of an algorithm change on Facebook’s ad performance?</p>
<p><strong>Answer:</strong> Stratification matching involves dividing the data into strata based on propensity scores and then comparing outcomes within each stratum. For an algorithm change on Facebook, users would be grouped into strata (e.g., quintiles) based on their propensity scores for being exposed to the new algorithm. Within each stratum, the ad performance of treated and control users is compared. The overall causal effect is estimated by averaging the within-stratum effects, weighted by the number of users in each stratum. For example, if in the top quintile, the ad performance improved by 5% for treated users compared to control, and similarly computed for other strata, we then aggregate these effects.</p>
</section>
</section>
<section id="instrumental-variables" class="level3">
<h3 class="anchored" data-anchor-id="instrumental-variables">Instrumental Variables</h3>
<section id="two-stage-least-squares-2sls" class="level4">
<h4 class="anchored" data-anchor-id="two-stage-least-squares-2sls">4. Two-Stage Least Squares (2SLS)</h4>
<p><strong>Question:</strong> Explain how you would use 2SLS to estimate the causal effect of social media usage on mental health.</p>
<p><strong>Answer:</strong> 2SLS is used when there is endogeneity, meaning that the treatment is correlated with the error term. We need an instrument – a variable that affects the treatment but not the outcome directly. In the first stage, we regress the treatment (social media usage) on the instrument (e.g., availability of high-speed internet). In the second stage, we use the predicted values from the first stage to regress the outcome (mental health). This approach helps isolate the causal impact of social media usage on mental health by leveraging the exogenous variation provided by the instrument. For example, if high-speed internet availability predicts higher social media usage but does not directly affect mental health, it serves as a valid instrument.</p>
</section>
<section id="generalized-method-of-moments-gmm" class="level4">
<h4 class="anchored" data-anchor-id="generalized-method-of-moments-gmm">5. Generalized Method of Moments (GMM)</h4>
<p><strong>Question:</strong> How can GMM be applied to study the effect of advertising on user retention on Instagram?</p>
<p><strong>Answer:</strong> GMM is an extension of instrumental variables that allows for more flexible assumptions and can handle multiple instruments. To study the effect of advertising on user retention, we identify instruments that influence advertising exposure but are unrelated to retention except through advertising (e.g., randomized ad distribution policies). GMM uses these instruments to create moment conditions that help estimate the parameters of interest. By solving these conditions, we obtain consistent estimates of the causal effect of advertising on retention. For instance, using the variation in ad exposure due to random distribution, we estimate its impact on user retention rates.</p>
</section>
</section>
<section id="difference-in-differences" class="level3">
<h3 class="anchored" data-anchor-id="difference-in-differences">Difference-in-Differences</h3>
<section id="difference-in-differences-did" class="level4">
<h4 class="anchored" data-anchor-id="difference-in-differences-did">6. Difference-in-Differences (DiD)</h4>
<p><strong>Question:</strong> How would you implement a DiD approach to measure the impact of a new privacy policy on user activity on Facebook?</p>
<p><strong>Answer:</strong> DiD compares the changes in outcomes over time between a treated group and a control group. To measure the impact of a new privacy policy on Facebook, we identify users affected by the policy (treated) and those who are not (control). We then compare the difference in user activity (e.g., posts, likes) before and after the policy implementation for both groups. The causal effect is the difference in these differences, which accounts for time trends and other confounders. For example, if the treated group’s activity decreased by 5% after the policy while the control group’s activity remained unchanged, the DiD estimate of the policy impact is -5%.</p>
</section>
</section>
<section id="regression-discontinuity-design" class="level3">
<h3 class="anchored" data-anchor-id="regression-discontinuity-design">Regression Discontinuity Design</h3>
<section id="sharp-regression-discontinuity-design-rdd" class="level4">
<h4 class="anchored" data-anchor-id="sharp-regression-discontinuity-design-rdd">7. Sharp Regression Discontinuity Design (RDD)</h4>
<p><strong>Question:</strong> Describe how a sharp RDD could be used to evaluate the impact of reaching a follower milestone on Instagram engagement.</p>
<p><strong>Answer:</strong> Sharp RDD exploits a cutoff point that determines treatment assignment. For Instagram, reaching a certain number of followers (e.g., 10,000) might grant users additional features (treatment). We compare engagement (e.g., likes, comments) for users just above and just below the cutoff. Because the assignment is essentially random near the threshold, the difference in engagement around the cutoff can be attributed to the treatment. For example, if users just above 10,000 followers have 15% higher engagement than those just below, we infer that the additional features cause the increase.</p>
</section>
<section id="fuzzy-regression-discontinuity-design-rdd" class="level4">
<h4 class="anchored" data-anchor-id="fuzzy-regression-discontinuity-design-rdd">8. Fuzzy Regression Discontinuity Design (RDD)</h4>
<p><strong>Question:</strong> How does a fuzzy RDD differ from a sharp RDD, and how could it be used to assess the effect of a verification badge on Twitter user behavior?</p>
<p><strong>Answer:</strong> In fuzzy RDD, the probability of treatment assignment changes discontinuously at the cutoff but not deterministically. For Twitter, not all users who meet the follower threshold receive a verification badge due to additional criteria. We use the discontinuity in the probability of receiving the badge at the cutoff to estimate its causal effect on user behavior (e.g., tweet frequency). The analysis involves comparing users around the threshold, adjusting for the probability of treatment assignment. For instance, we may find that users near the threshold who are verified show a 10% increase in tweet frequency compared to those not verified, adjusted for the likelihood of receiving the badge.</p>
</section>
</section>
<section id="causal-graphical-models" class="level3">
<h3 class="anchored" data-anchor-id="causal-graphical-models">Causal Graphical Models</h3>
<section id="directed-acyclic-graphs-dags" class="level4">
<h4 class="anchored" data-anchor-id="directed-acyclic-graphs-dags">9. Directed Acyclic Graphs (DAGs)</h4>
<p><strong>Question:</strong> Explain how you would use a DAG to identify potential confounders in studying the effect of social media exposure on user well-being.</p>
<p><strong>Answer:</strong> A DAG visually represents causal relationships between variables. To study the effect of social media exposure on user well-being, we draw a DAG with nodes representing variables (e.g., social media exposure, user well-being, demographics) and directed edges indicating causal relationships. We identify confounders as variables that influence both the treatment and outcome. For instance, age and socioeconomic status might affect both social media usage and well-being. Adjusting for these confounders in our analysis helps isolate the causal effect. For example, by identifying age as a confounder, we control for it in our models to better estimate the impact of social media exposure on well-being.</p>
</section>
<section id="structural-causal-models" class="level4">
<h4 class="anchored" data-anchor-id="structural-causal-models">10. Structural Causal Models</h4>
<p><strong>Question:</strong> How would you apply a structural causal model to analyze the impact of targeted advertising on purchase behavior on Facebook?</p>
<p><strong>Answer:</strong> Structural causal models (SCMs) extend DAGs by specifying functional relationships between variables. To analyze targeted advertising’s impact, we construct an SCM with equations representing how targeted ads influence purchase behavior, considering mediators (e.g., ad engagement) and confounders (e.g., user interests). By solving the model, we can simulate interventions (e.g., increasing ad frequency) and predict their causal effects on purchases, providing insights into the effectiveness of targeted advertising strategies. For example, we might find that increasing ad frequency by 10% leads to a 5% increase in purchase behavior, mediated by higher ad engagement.</p>
</section>
</section>
<section id="potential-outcomes-framework" class="level3">
<h3 class="anchored" data-anchor-id="potential-outcomes-framework">Potential Outcomes Framework</h3>
<section id="average-treatment-effect-ate" class="level4">
<h4 class="anchored" data-anchor-id="average-treatment-effect-ate">11. Average Treatment Effect (ATE)</h4>
<p><strong>Question:</strong> How would you estimate the ATE of a new content recommendation algorithm on user engagement on Instagram?</p>
<p><strong>Answer:</strong> The ATE is the average difference in outcomes between treated and untreated units. For Instagram, we randomly assign users to the new algorithm (treatment) or the old one (control). We then measure engagement (e.g., time spent) for both groups. The ATE is the difference in average engagement between the two groups. Random assignment ensures that the estimated effect is causal, reflecting the algorithm’s impact on engagement. For instance, if users with the new algorithm spend 30 minutes more on average than those with the old one, the ATE is 30 minutes.</p>
</section>
<section id="average-treatment-effect-on-the-treated-att" class="level4">
<h4 class="anchored" data-anchor-id="average-treatment-effect-on-the-treated-att">12. Average Treatment Effect on the Treated (ATT)</h4>
<p><strong>Question:</strong> What is the ATT, and how would you calculate it for a promotional campaign on Facebook?</p>
<p><strong>Answer:</strong> The ATT measures the average effect of treatment on those who actually receive it. For a Facebook promotional campaign, we identify users exposed to the promotion (treated) and a comparable group not exposed (control). We estimate the ATT by comparing the average outcome (e.g., purchases) between treated users and matched control users with similar characteristics. This helps understand the campaign’s impact on the targeted audience. For instance, if treated users made 20% more purchases than their matched controls, the ATT is a 20% increase.</p>
</section>
</section>
<section id="mediation-analysis" class="level3">
<h3 class="anchored" data-anchor-id="mediation-analysis">Mediation Analysis</h3>
<section id="mediation-analysis-1" class="level4">
<h4 class="anchored" data-anchor-id="mediation-analysis-1">13. Mediation Analysis</h4>
<p><strong>Question:</strong> Describe how you would conduct mediation analysis to explore how user interaction with ads leads to purchases on Instagram.</p>
<p><strong>Answer:</strong> Mediation analysis investigates how a treatment affects an outcome through a mediator. For Instagram ads, we hypothesize that ad interaction (mediator) influences purchases (outcome). We estimate the direct effect of ads on purchases and the indirect effect through interaction. This involves fitting models for the mediator (interaction given ad exposure) and the outcome (purchases given interaction and ad exposure). The total effect is decomposed into direct and indirect effects, revealing the pathways through which ads drive purchases. For example, we might find that 70% of the ad effect on purchases is mediated through increased user interaction.</p>
</section>
</section>
<section id="sensitivity-analysis-for-causal-inference" class="level3">
<h3 class="anchored" data-anchor-id="sensitivity-analysis-for-causal-inference">Sensitivity Analysis for Causal Inference</h3>
<section id="sensitivity-analysis" class="level4">
<h4 class="anchored" data-anchor-id="sensitivity-analysis">14. Sensitivity Analysis</h4>
<p><strong>Question:</strong> How would you perform a sensitivity analysis to assess the robustness of your causal estimates for a new feature rollout on Facebook?</p>
<p><strong>Answer:</strong> Sensitivity analysis evaluates how sensitive causal estimates are to potential violations of assumptions. For a Facebook feature rollout, we test the robustness of our estimates by varying assumptions about unobserved confounders, measurement errors, or model specifications. Techniques include bounding the treatment effect under different scenarios or using methods like Rosenbaum bounds to quantify how strong an unmeasured confounder must be to nullify the observed effect. This helps gauge the credibility of our causal conclusions. For example, we might find that our estimated effect remains significant even if unobserved confounders were twice as strong as observed ones.</p>
</section>
</section>
<section id="synthetic-control-methods" class="level3">
<h3 class="anchored" data-anchor-id="synthetic-control-methods">Synthetic Control Methods</h3>
<section id="synthetic-control-methods-1" class="level4">
<h4 class="anchored" data-anchor-id="synthetic-control-methods-1">15. Synthetic Control Methods</h4>
<p><strong>Question:</strong> How would you use synthetic control methods to evaluate the effect of a major policy change on user retention on a social media platform?</p>
<p><strong>Answer:</strong> Synthetic control methods create a weighted combination of control units to construct a synthetic version of the treated unit, mimicking what would have happened without the treatment. For a major policy change on a social media platform, we select a group of untreated users and assign weights to create a synthetic control that closely matches the treated group’s pre-policy characteristics. We then compare post-policy retention rates between the treated group and the synthetic control, attributing differences to the policy change. For example, if the treated group’s retention rate drops by 5% compared to the synthetic control, we attribute this drop to the policy change.</p>
</section>
</section>
<section id="causal-forests" class="level3">
<h3 class="anchored" data-anchor-id="causal-forests">Causal Forests</h3>
<section id="causal-forests-1" class="level4">
<h4 class="anchored" data-anchor-id="causal-forests-1">16. Causal Forests</h4>
<p><strong>Question:</strong> Explain how causal forests can be used to estimate heterogeneous treatment effects of a new engagement strategy on Facebook.</p>
<p><strong>Answer:</strong> Causal forests extend random forests to estimate heterogeneous treatment effects. They partition the data into trees, allowing for complex interactions and non-linearities. For a new engagement strategy on Facebook, we use causal forests to estimate the treatment effect for different user subgroups (e.g., based on activity level, demographics). By examining the distribution of treatment effects across trees, we identify which users benefit most from the strategy, informing targeted interventions. For instance, we might find that the strategy is most effective for users under 30, leading to a 15% increase in engagement.</p>
</section>
</section>
<section id="double-machine-learning" class="level3">
<h3 class="anchored" data-anchor-id="double-machine-learning">Double Machine Learning</h3>
<section id="double-machine-learning-1" class="level4">
<h4 class="anchored" data-anchor-id="double-machine-learning-1">17. Double Machine Learning</h4>
<p><strong>Question:</strong> How can double machine learning be applied to control for high-dimensional confounders when estimating the effect of social media features on user behavior?</p>
<p><strong>Answer:</strong> Double machine learning combines machine learning with causal inference to control for high-dimensional confounders. We use machine learning models (e.g., random forests, LASSO) to estimate the relationship between confounders and both the treatment and outcome. For social media features, we first predict feature exposure and user behavior using confounders. We then use these predictions to isolate the causal effect, accounting for complex confounding structures. This approach improves the accuracy of causal estimates in high-dimensional settings. For example, controlling for hundreds of user characteristics, we might estimate that a new feature increases user activity by 10%.</p>
</section>
</section>
<section id="targeted-maximum-likelihood-estimation-tmle" class="level3">
<h3 class="anchored" data-anchor-id="targeted-maximum-likelihood-estimation-tmle">Targeted Maximum Likelihood Estimation (TMLE)</h3>
<section id="targeted-maximum-likelihood-estimation-tmle-1" class="level4">
<h4 class="anchored" data-anchor-id="targeted-maximum-likelihood-estimation-tmle-1">18. Targeted Maximum Likelihood Estimation (TMLE)</h4>
<p><strong>Question:</strong> Describe the TMLE approach and its application in evaluating the effect of algorithmic changes on content engagement on Instagram.</p>
<p><strong>Answer:</strong> TMLE is a semi-parametric method that combines machine learning with maximum likelihood estimation to reduce bias and improve efficiency. For evaluating algorithmic changes on Instagram, TMLE involves specifying an initial model for engagement and updating it using targeted learning. This process iteratively adjusts the model to better estimate the treatment effect while accounting for confounders and censoring. TMLE provides robust causal estimates, leveraging data-driven model improvements. For example, we might use TMLE to estimate that the algorithmic change increases engagement by 12%, adjusting for user demographics and previous engagement levels.</p>
</section>
</section>
<section id="causal-discovery-algorithms" class="level3">
<h3 class="anchored" data-anchor-id="causal-discovery-algorithms">Causal Discovery Algorithms</h3>
<section id="causal-discovery-algorithms-1" class="level4">
<h4 class="anchored" data-anchor-id="causal-discovery-algorithms-1">19. Causal Discovery Algorithms</h4>
<p><strong>Question:</strong> How can causal discovery algorithms help identify causal relationships in social media data?</p>
<p><strong>Answer:</strong> Causal discovery algorithms analyze observational data to uncover causal relationships, often using constraints from graphical models. For social media data, algorithms like PC or FCI can identify causal links between variables (e.g., user interactions, content type, engagement). These methods test for conditional independencies to infer the underlying causal structure, providing insights into how different factors influence user behavior and guiding further causal analysis. For example, we might use these algorithms to discover that increased interaction with video content causally increases overall engagement on the platform.</p>
</section>
</section>
<section id="longitudinal-causal-inference" class="level3">
<h3 class="anchored" data-anchor-id="longitudinal-causal-inference">Longitudinal Causal Inference</h3>
<section id="longitudinal-causal-inference-1" class="level4">
<h4 class="anchored" data-anchor-id="longitudinal-causal-inference-1">20. Longitudinal Causal Inference</h4>
<p><strong>Question:</strong> How would you approach longitudinal causal inference to study the long-term effects of a new social media feature on user engagement?</p>
<p><strong>Answer:</strong> Longitudinal causal inference analyzes data collected over time to estimate causal effects. For a new social media feature, we use repeated measures of user engagement before and after feature introduction. Techniques like fixed effects models or marginal structural models account for time-varying confounders and allow for the estimation of both short-term and long-term effects. By modeling the temporal dynamics, we gain insights into how the feature influences engagement over time and adapt strategies accordingly. For instance, we might find that the feature initially boosts engagement by 20%, but this effect diminishes to 5% over six months.</p>
</section>
</section>
</section>
</section>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>