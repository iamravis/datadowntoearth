<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.47">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Ravi Shankar">

<title>advanced_data_processing – Data Down To Earth</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../logo.png" rel="icon" type="image/png">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../../styles.css">
<link rel="stylesheet" href="../../content.css">
<meta property="og:title" content="– Data Down To Earth">
<meta property="og:site_name" content="Data Down To Earth">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Data Down To Earth</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-projects" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Projects</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-projects">    
        <li>
    <a class="dropdown-item" href="../../../projects/dsml_projects.html">
 <span class="dropdown-text">Data Science and ML Projects</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../projects/genai_projects.html">
 <span class="dropdown-text">Generative AI Projects</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-tutorials" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Tutorials</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-tutorials">    
        <li>
    <a class="dropdown-item" href="../../../topics/statistics.html">
 <span class="dropdown-text">Statistics &amp; Probability</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/machine_learning.html">
 <span class="dropdown-text">Machine Learning</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/de.html">
 <span class="dropdown-text">Data Engineering</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/generative_ai.html">
 <span class="dropdown-text">Generative AI</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/public_health.html">
 <span class="dropdown-text">Public Health</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/product_sense.html">
 <span class="dropdown-text">Product Sense</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../../notes/notes.html"> 
<span class="menu-text">Notes</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/iamrsps"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/iamravishankar/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content column-page" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
</div>



<div class="quarto-title-meta column-page">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Ravi Shankar </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="chapter-9-advanced-data-processing" class="level1 text-content">
<h1>Chapter 9: Advanced Data Processing</h1>
<section id="distributed-computing-concepts" class="level2">
<h2 class="anchored" data-anchor-id="distributed-computing-concepts">Distributed Computing Concepts</h2>
<section id="definition" class="level3">
<h3 class="anchored" data-anchor-id="definition">Definition</h3>
<p>Distributed computing involves dividing a large problem into smaller tasks, distributing these tasks across multiple computing nodes, and aggregating the results. This approach leverages the combined processing power of multiple machines to achieve faster computation and handle large-scale data processing.</p>
</section>
<section id="key-concepts" class="level3">
<h3 class="anchored" data-anchor-id="key-concepts">Key Concepts</h3>
<ul>
<li><p><strong>Parallelism</strong>: The simultaneous execution of multiple tasks across different processors or machines to increase computational speed.</p></li>
<li><p><strong>Scalability</strong>: The ability of a system to handle increasing workloads by adding more nodes or resources, ensuring consistent performance as demand grows.</p></li>
<li><p><strong>Fault Tolerance</strong>: The capability of a system to continue operating correctly in the event of failures of some of its components, achieved through data replication and task re-execution.</p></li>
<li><p><strong>Consistency</strong>: Ensuring that all nodes in a distributed system have the same view of data at any given time, often managed through distributed consensus algorithms like Paxos or Raft.</p></li>
</ul>
</section>
<section id="example" class="level3">
<h3 class="anchored" data-anchor-id="example">Example</h3>
<p>A distributed computing system for weather forecasting, where data from various sensors and satellite images are processed in parallel across multiple nodes to generate accurate and timely weather predictions.</p>
<hr>
</section>
</section>
<section id="apache-spark-internals" class="level2">
<h2 class="anchored" data-anchor-id="apache-spark-internals">Apache Spark Internals</h2>
<section id="rdds-dataframes-and-datasets" class="level3">
<h3 class="anchored" data-anchor-id="rdds-dataframes-and-datasets">RDDs, DataFrames, and Datasets</h3>
<section id="rdds" class="level4">
<h4 class="anchored" data-anchor-id="rdds">RDDs</h4>
<p><strong>Definition</strong>: Resilient Distributed Datasets (RDDs) are the fundamental data structure in Spark, representing an immutable, distributed collection of objects that can be processed in parallel. RDDs provide fault tolerance through lineage information, which allows them to be recomputed in case of node failures.</p>
<p><strong>Operations</strong>: RDDs support two types of operations: transformations (e.g., map, filter) and actions (e.g., reduce, collect). Transformations create new RDDs from existing ones, while actions return results to the driver program or write data to external storage.</p>
<p><strong>Example</strong>: An RDD representing a log file, where each line is processed in parallel to extract useful information, such as error messages or user activity statistics.</p>
</section>
<section id="dataframes" class="level4">
<h4 class="anchored" data-anchor-id="dataframes">DataFrames</h4>
<p><strong>Definition</strong>: DataFrames are a higher-level abstraction in Spark, providing a distributed collection of data organized into named columns, similar to a table in a relational database. They offer a more expressive and optimized API compared to RDDs, enabling easier data manipulation and analysis.</p>
<p><strong>Operations</strong>: DataFrames support SQL-like operations such as select, filter, groupBy, and join, allowing users to write concise and efficient code for data processing tasks.</p>
<p><strong>Example</strong>: A DataFrame representing sales data, where columns include transaction ID, product ID, quantity, and price. Users can easily filter sales by date range, group by product category, and calculate total revenue.</p>
</section>
<section id="datasets" class="level4">
<h4 class="anchored" data-anchor-id="datasets">Datasets</h4>
<p><strong>Definition</strong>: Datasets are a typed extension of DataFrames, providing the benefits of both RDDs (type safety and object-oriented programming) and DataFrames (optimizations and SQL-like API). They offer compile-time type checking and can be used with custom Java or Scala objects.</p>
<p><strong>Operations</strong>: Datasets support the same operations as DataFrames, but with the added advantage of type safety, enabling users to leverage the full power of the Scala or Java type system for complex data manipulation tasks.</p>
<p><strong>Example</strong>: A Dataset representing user data, where each record is a custom User object with fields like userId, name, and email. Users can filter, group, and aggregate user data with compile-time type safety.</p>
</section>
</section>
<section id="spark-sql-and-catalyst-optimizer" class="level3">
<h3 class="anchored" data-anchor-id="spark-sql-and-catalyst-optimizer">Spark SQL and Catalyst Optimizer</h3>
<section id="spark-sql" class="level4">
<h4 class="anchored" data-anchor-id="spark-sql">Spark SQL</h4>
<p><strong>Definition</strong>: Spark SQL is a Spark module for structured data processing, allowing users to run SQL queries on DataFrames and Datasets. It provides a unified interface for reading, writing, and querying structured data from various sources, including Hive, Avro, Parquet, and JSON.</p>
<p><strong>Features</strong>: Spark SQL integrates with Spark’s core API and supports both batch and streaming data processing. It also provides seamless integration with existing BI tools through JDBC/ODBC connectors.</p>
<p><strong>Example</strong>: Running a SQL query to join two DataFrames representing customer and order data, filtering the results to include only high-value orders, and aggregating the total revenue by customer.</p>
</section>
<section id="catalyst-optimizer" class="level4">
<h4 class="anchored" data-anchor-id="catalyst-optimizer">Catalyst Optimizer</h4>
<p><strong>Definition</strong>: Catalyst is the query optimization engine used by Spark SQL. It performs advanced optimizations to improve query execution performance, such as predicate pushdown, column pruning, and join reordering. Catalyst uses a rule-based and cost-based approach to optimize logical and physical query plans.</p>
<p><strong>Process</strong>: Catalyst first converts SQL queries into an abstract syntax tree (AST), then applies logical optimization rules to produce an optimized logical plan. It further optimizes the plan by applying physical optimization rules, selecting the most efficient execution strategies based on cost estimation.</p>
<p><strong>Example</strong>: Optimizing a complex SQL query with multiple joins and aggregations, where Catalyst reorders the joins and applies predicate pushdown to minimize data shuffling and reduce query execution time.</p>
</section>
</section>
<section id="tungsten-execution-engine" class="level3">
<h3 class="anchored" data-anchor-id="tungsten-execution-engine">Tungsten Execution Engine</h3>
<p><strong>Definition</strong>: The Tungsten execution engine is a major component of Spark’s core execution engine, designed to optimize CPU and memory efficiency. It includes several optimizations, such as whole-stage code generation, vectorized processing, and cache-aware computation.</p>
<p><strong>Features</strong>: - <strong>Whole-stage Code Generation</strong>: Generates optimized bytecode at runtime for entire stages of execution, reducing the overhead of function calls and improving execution speed.</p>
<ul>
<li><p><strong>Vectorized Processing</strong>: Processes multiple rows of data at a time using low-level CPU instructions, significantly improving performance for in-memory operations.</p></li>
<li><p><strong>Cache-aware Computation</strong>: Optimizes memory access patterns to leverage CPU caches, reducing memory latency and increasing throughput.</p></li>
</ul>
<p><strong>Example</strong>: Using Tungsten’s whole-stage code generation to optimize a Spark job that performs a series of transformations and aggregations on a large dataset, resulting in significant performance improvements compared to non-optimized execution.</p>
<hr>
</section>
</section>
<section id="advanced-spark-techniques" class="level2">
<h2 class="anchored" data-anchor-id="advanced-spark-techniques">Advanced Spark Techniques</h2>
<section id="partitioning-and-bucketing" class="level3">
<h3 class="anchored" data-anchor-id="partitioning-and-bucketing">Partitioning and Bucketing</h3>
<p><strong>Definition</strong>: Partitioning and bucketing are techniques used to organize data within a distributed storage system to improve query performance and resource utilization. Partitioning divides data into distinct subsets based on specific column values, while bucketing further groups these subsets into fixed-size buckets based on hash functions.</p>
<p><strong>Partitioning</strong>: Partitioning improves data retrieval speed by limiting the amount of data scanned during query execution. It is particularly effective for filtering queries on partition columns.</p>
<p><strong>Bucketing</strong>: Bucketing helps with efficient join operations and aggregations by co-locating related data into fixed-size buckets, reducing the amount of data shuffled during query execution.</p>
<p><strong>Example</strong>: Partitioning a sales dataset by year and month, and further bucketing it by customer ID, to speed up queries filtering by date and aggregating sales data by customer.</p>
</section>
<section id="caching-and-persistence" class="level3">
<h3 class="anchored" data-anchor-id="caching-and-persistence">Caching and Persistence</h3>
<p><strong>Definition</strong>: Caching and persistence are techniques used to store intermediate results of a Spark computation in memory or on disk, reducing the need to recompute these results in subsequent stages of the computation. This can significantly improve the performance of iterative algorithms and complex workflows.</p>
<p><strong>Caching</strong>: Caching stores RDDs, DataFrames, or Datasets in memory, providing fast access to intermediate results. Spark offers different storage levels, such as MEMORY_ONLY, MEMORY_AND_DISK, and DISK_ONLY, to control how data is cached.</p>
<p><strong>Persistence</strong>: Persistence is similar to caching but provides more control over storage levels and the ability to explicitly save data to disk. It is useful for ensuring data durability and handling large datasets that cannot fit entirely in memory.</p>
<p><strong>Example</strong>: Caching a DataFrame representing a large dataset of user interactions to speed up multiple iterative processing steps, such as feature extraction and model training, in a machine learning pipeline.</p>
</section>
<section id="performance-tuning-and-optimization" class="level3">
<h3 class="anchored" data-anchor-id="performance-tuning-and-optimization">Performance Tuning and Optimization</h3>
<p><strong>Definition</strong>: Performance tuning and optimization involve adjusting various parameters and applying best practices to improve the efficiency and speed of Spark jobs. This includes optimizing resource allocation, tuning configuration settings, and leveraging advanced features of Spark’s execution engine.</p>
<p><strong>Techniques</strong>: - <strong>Resource Allocation</strong>: Adjusting the number of executors, cores per executor, and memory per executor to balance the workload and prevent resource bottlenecks.</p>
<ul>
<li><p><strong>Configuration Settings</strong>: Tuning Spark configuration parameters, such as spark.sql.shuffle.partitions, spark.executor.memory, and spark.driver.memory, to optimize the performance of specific workloads.</p></li>
<li><p><strong>Advanced Features</strong>: Leveraging features like dynamic allocation, speculative execution, and adaptive query execution to improve job performance and resilience to variations in data and workload characteristics.</p></li>
</ul>
<p><strong>Example</strong>: Tuning the spark.sql.shuffle.partitions parameter to reduce the number of shuffle partitions for a specific job, minimizing shuffle overhead and improving execution time for a large-scale data processing task.</p>
<hr>
</section>
</section>
<section id="presto-for-interactive-queries" class="level2">
<h2 class="anchored" data-anchor-id="presto-for-interactive-queries">Presto for Interactive Queries</h2>
<section id="definition-1" class="level3">
<h3 class="anchored" data-anchor-id="definition-1">Definition</h3>
<p>Presto is an open-source distributed SQL query engine designed for running interactive analytic queries against various data sources. It supports querying data from multiple sources, including Hadoop, AWS S3, MySQL, PostgreSQL, and Kafka, using a single SQL query.</p>
</section>
<section id="architecture" class="level3">
<h3 class="anchored" data-anchor-id="architecture">Architecture</h3>
<p>Presto uses a distributed architecture with a coordinator node that parses queries, plans execution, and manages worker nodes that execute query fragments in parallel. This architecture allows Presto to achieve high performance and low-latency query execution.</p>
</section>
<section id="features" class="level3">
<h3 class="anchored" data-anchor-id="features">Features</h3>
<p>Presto supports ANSI SQL, complex queries, and various data formats, including ORC, Parquet, and Avro. It provides advanced optimization techniques, such as predicate pushdown, column pruning, and dynamic filtering, to improve query performance.</p>
</section>
<section id="example-1" class="level3">
<h3 class="anchored" data-anchor-id="example-1">Example</h3>
<p>Using Presto to query a data lake stored in AWS S3, joining data from multiple sources, such as clickstream logs, product catalogs, and user profiles, to generate real-time insights into user behavior and product performance.</p>
<hr>
</section>
</section>
<section id="apache-druid-for-real-time-analytics" class="level2">
<h2 class="anchored" data-anchor-id="apache-druid-for-real-time-analytics">Apache Druid for Real-time Analytics</h2>
<section id="definition-2" class="level3">
<h3 class="anchored" data-anchor-id="definition-2">Definition</h3>
<p>Apache Druid is a high-performance, real-time analytics database designed for fast slice-and-dice analytics on large datasets. It combines the features of a time-series database, a column-oriented data store, and a distributed search engine.</p>
</section>
<section id="architecture-1" class="level3">
<h3 class="anchored" data-anchor-id="architecture-1">Architecture</h3>
<p>Druid’s architecture consists of various node types, including real-time nodes for ingesting and indexing data in real-time, historical nodes for storing and querying large volumes of immutable data, and broker nodes for routing queries to the appropriate nodes.</p>
</section>
<section id="features-1" class="level3">
<h3 class="anchored" data-anchor-id="features-1">Features</h3>
<p>Druid supports real-time data ingestion, high query performance, and low-latency data exploration. It provides a flexible data model, advanced indexing techniques, and built-in support for complex aggregations, filtering, and time-based queries.</p>
</section>
<section id="example-2" class="level3">
<h3 class="anchored" data-anchor-id="example-2">Example</h3>
<p>Using Apache Druid to power a real-time dashboard for monitoring website traffic and user engagement, allowing analysts to explore data interactively and gain insights into user behavior, performance issues, and marketing effectiveness in real-time.</p>
</section>
</section>
</section>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>