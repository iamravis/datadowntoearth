<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.47">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Ravi Shankar">

<title>data_modeling_and_schema_design – Data Down To Earth</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../logo.png" rel="icon" type="image/png">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../../styles.css">
<link rel="stylesheet" href="../../content.css">
<meta property="og:title" content="– Data Down To Earth">
<meta property="og:site_name" content="Data Down To Earth">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Data Down To Earth</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-projects" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Projects</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-projects">    
        <li>
    <a class="dropdown-item" href="../../../projects/dsml_projects.html">
 <span class="dropdown-text">Data Science and ML Projects</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../projects/genai_projects.html">
 <span class="dropdown-text">Generative AI Projects</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-tutorials" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Tutorials</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-tutorials">    
        <li>
    <a class="dropdown-item" href="../../../topics/statistics.html">
 <span class="dropdown-text">Statistics &amp; Probability</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/machine_learning.html">
 <span class="dropdown-text">Machine Learning</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/de.html">
 <span class="dropdown-text">Data Engineering</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/generative_ai.html">
 <span class="dropdown-text">Generative AI</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/public_health.html">
 <span class="dropdown-text">Public Health</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/product_sense.html">
 <span class="dropdown-text">Product Sense</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../../notes/notes.html"> 
<span class="menu-text">Notes</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/iamrsps"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/iamravishankar/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content column-page" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
</div>



<div class="quarto-title-meta column-page">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Ravi Shankar </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="chapter-10-data-modeling-and-schema-design" class="level1 text-content">
<h1>Chapter 10: Data Modeling and Schema Design</h1>
<section id="normalization-and-denormalization" class="level2">
<h2 class="anchored" data-anchor-id="normalization-and-denormalization">Normalization and Denormalization</h2>
<section id="normalization" class="level3">
<h3 class="anchored" data-anchor-id="normalization">Normalization</h3>
<p><strong>Definition</strong>: Normalization is the process of organizing a database to reduce redundancy and improve data integrity. It involves dividing a database into two or more tables and defining relationships between them. This ensures that each piece of data is stored only once, reducing the potential for data anomalies.</p>
<p><strong>Normal Forms</strong>: Normalization follows a series of normal forms (1NF, 2NF, 3NF, BCNF, etc.), each with specific rules: - <strong>1NF</strong>: Ensures that the table has a primary key and that each column contains atomic values without repeating groups.</p>
<ul>
<li><p><strong>2NF</strong>: Ensures that the table is in 1NF and that all non-key attributes are fully functionally dependent on the primary key.</p></li>
<li><p><strong>3NF</strong>: Ensures that the table is in 2NF and that all non-key attributes are not transitively dependent on the primary key.</p></li>
</ul>
<p><strong>Example</strong>: In a normalized database for a bookstore, separate tables would be used for authors, books, and publishers, with foreign keys linking related records. This eliminates redundancy, such as storing the author’s name with every book entry, and ensures data integrity.</p>
<p><strong>Advantages</strong>: - Reduces data redundancy - Improves data integrity - Simplifies updates and deletions - Ensures data consistency</p>
<p><strong>Disadvantages</strong>: - Can result in complex queries and joins - Potentially impacts performance - Makes the database harder to understand and maintain</p>
</section>
<section id="denormalization" class="level3">
<h3 class="anchored" data-anchor-id="denormalization">Denormalization</h3>
<p><strong>Definition</strong>: Denormalization is the process of combining tables to reduce the number of joins in queries, improving read performance at the cost of increased redundancy and potential data anomalies. It is often used in OLAP (Online Analytical Processing) systems where query performance is critical.</p>
<p><strong>Techniques</strong>: Denormalization can involve adding redundant data, creating summary tables, or merging tables that are frequently joined in queries.</p>
<p><strong>Example</strong>: In a denormalized database for a bookstore, a single table might contain book details, author names, and publisher information, reducing the need for joins in queries but introducing redundancy.</p>
<p><strong>Advantages</strong>: - Improves read performance - Simplifies query writing - Beneficial for read-heavy applications like data warehouses</p>
<p><strong>Disadvantages</strong>: - Increases data redundancy - Can lead to data anomalies - Complicates update and delete operations</p>
<hr>
</section>
</section>
<section id="star-schema-vs.-snowflake-schema" class="level2">
<h2 class="anchored" data-anchor-id="star-schema-vs.-snowflake-schema">Star Schema vs.&nbsp;Snowflake Schema</h2>
<section id="star-schema" class="level3">
<h3 class="anchored" data-anchor-id="star-schema">Star Schema</h3>
<p><strong>Definition</strong>: A star schema is a type of database schema used in data warehousing. It consists of a central fact table connected to multiple dimension tables. The fact table stores quantitative data (e.g., sales amounts), while dimension tables store descriptive data (e.g., product details, dates).</p>
<p><strong>Structure</strong>: The star schema has a simple, denormalized structure where dimension tables are not normalized, resulting in fewer joins and faster query performance.</p>
<p><strong>Example</strong>: A sales data warehouse with a central fact table for sales transactions and dimension tables for products, customers, and time periods. Queries can quickly access related dimensions without complex joins.</p>
<p><strong>Advantages</strong>: - Simplifies queries - Improves query performance - Easy to understand and implement</p>
<p><strong>Disadvantages</strong>: - Increases data redundancy - Can lead to inconsistencies if dimension data is not carefully managed</p>
</section>
<section id="snowflake-schema" class="level3">
<h3 class="anchored" data-anchor-id="snowflake-schema">Snowflake Schema</h3>
<p><strong>Definition</strong>: A snowflake schema is a more normalized form of a star schema where dimension tables are further divided into related tables. This reduces redundancy but increases the complexity of queries due to additional joins.</p>
<p><strong>Structure</strong>: Dimension tables are normalized into multiple related tables, resembling a snowflake shape in the schema diagram. This structure eliminates redundancy in dimension data.</p>
<p><strong>Example</strong>: A sales data warehouse with a fact table for sales transactions, and dimension tables for products, customers, and time periods, where each dimension table is further normalized into related tables (e.g., customer addresses, product categories).</p>
<p><strong>Advantages</strong>: - Reduces data redundancy and storage requirements - Ensures data consistency and integrity</p>
<p><strong>Disadvantages</strong>: - Complicates queries with more joins - Potentially impacts query performance - More difficult to implement and maintain</p>
<hr>
</section>
</section>
<section id="slowly-changing-dimensions-scds" class="level2">
<h2 class="anchored" data-anchor-id="slowly-changing-dimensions-scds">Slowly Changing Dimensions (SCDs)</h2>
<p><strong>Definition</strong>: Slowly Changing Dimensions (SCDs) are dimensions in a data warehouse that change slowly over time, rather than changing on a regular schedule, time-base, or simply being immutable. SCDs track changes in dimension attributes, preserving historical data while reflecting current values.</p>
<p><strong>Types</strong>: - <strong>Type 0</strong>: Retain original value; no changes are tracked (static dimension).</p>
<ul>
<li><p><strong>Type 1</strong>: Overwrite old data with new data, without preserving history.</p></li>
<li><p><strong>Type 2</strong>: Create a new record for each change, preserving history with a versioning mechanism (e.g., start and end dates, current flag).</p></li>
<li><p><strong>Type 3</strong>: Track changes using additional columns, allowing comparison of current and previous values within the same record.</p></li>
<li><p><strong>Type 4</strong>: Use historical and current tables to track changes, separating current data from historical data.</p></li>
<li><p><strong>Type 6 (Hybrid)</strong>: Combines aspects of Types 1, 2, and 3 to track changes, providing a comprehensive approach to managing SCDs.</p></li>
</ul>
<p><strong>Example</strong>: A customer dimension in a retail data warehouse where customer addresses change over time. Type 2 SCD would create new records for each address change, preserving historical addresses, while a Type 1 SCD would overwrite the old address with the new one.</p>
<hr>
</section>
<section id="data-vault-modeling" class="level2">
<h2 class="anchored" data-anchor-id="data-vault-modeling">Data Vault Modeling</h2>
<p><strong>Definition</strong>: Data Vault modeling is a database modeling method designed to provide long-term historical storage of data coming from multiple operational systems. It is highly scalable, adaptable, and audit-friendly, making it suitable for large, complex data warehouses.</p>
<p><strong>Components</strong>: - <strong>Hubs</strong>: Contain unique business keys and metadata, representing core business concepts (e.g., customers, products).</p>
<ul>
<li><p><strong>Links</strong>: Capture relationships between hubs, providing the associations between business concepts (e.g., customer purchases, product sales).</p></li>
<li><p><strong>Satellites</strong>: Store descriptive data related to hubs and links, allowing for tracking historical changes and providing context (e.g., customer attributes, product details).</p></li>
</ul>
<p><strong>Example</strong>: A data vault model for an e-commerce company with hubs for customers and products, links for transactions, and satellites for customer details, product attributes, and transaction metadata. This structure supports scalable, flexible data integration and historical tracking.</p>
<p><strong>Advantages</strong>: - Supports scalability, historical tracking, and auditability - Flexible and adaptable design for complex, evolving data environments</p>
<p><strong>Disadvantages</strong>: - Can result in complex models with numerous tables - Requires careful management and potentially impacts query performance</p>
<hr>
</section>
<section id="anchor-modeling" class="level2">
<h2 class="anchored" data-anchor-id="anchor-modeling">Anchor Modeling</h2>
<p><strong>Definition</strong>: Anchor modeling is an agile database modeling technique focused on flexibility, extensibility, and temporal data management. It organizes data into anchors (core entities), attributes (properties of anchors), and ties (relationships between anchors), supporting historical tracking and schema evolution.</p>
<p><strong>Components</strong>: - <strong>Anchors</strong>: Represent core business entities (e.g., customers, products), each with a unique identifier.</p>
<ul>
<li><p><strong>Attributes</strong>: Capture properties of anchors, stored in separate tables with temporal data to track changes over time (e.g., customer name, product price).</p></li>
<li><p><strong>Ties</strong>: Define relationships between anchors, also stored in separate tables with temporal data for historical tracking (e.g., customer purchases, product categories).</p></li>
</ul>
<p><strong>Example</strong>: An anchor model for a retail company with anchors for customers and products, attributes for customer details and product attributes, and ties for customer transactions and product categories. This structure allows for easy schema evolution and historical tracking.</p>
<p><strong>Advantages</strong>: - Provides flexibility, supports schema evolution - Enables detailed historical tracking - Suitable for dynamic and complex data environments</p>
<p><strong>Disadvantages</strong>: - Can result in numerous tables and joins - Potentially impacts query performance - Requires careful management of temporal data</p>
<hr>
</section>
<section id="json-and-semi-structured-data-modeling" class="level2">
<h2 class="anchored" data-anchor-id="json-and-semi-structured-data-modeling">JSON and Semi-structured Data Modeling</h2>
<p><strong>Definition</strong>: JSON and semi-structured data modeling involves designing schemas for data that does not fit into a traditional relational model, such as nested or hierarchical data. This approach provides flexibility in handling varying data structures and evolving schemas, commonly used in NoSQL databases and big data systems.</p>
<p><strong>Techniques</strong>: - <strong>Document-based Modeling</strong>: Stores data as documents (e.g., JSON, BSON) with nested structures, allowing for flexible and dynamic schemas (e.g., MongoDB).</p>
<ul>
<li><p><strong>Key-value Modeling</strong>: Stores data as key-value pairs, suitable for simple, unstructured data with high write and read performance (e.g., Redis, DynamoDB).</p></li>
<li><p><strong>Column-family Modeling</strong>: Organizes data into columns and rows, but with flexible schema design, allowing for efficient storage and retrieval of semi-structured data (e.g., Cassandra, HBase).</p></li>
</ul>
<p><strong>Example</strong>: A JSON document representing a customer with nested attributes for contact details, order history, and preferences. This document can be stored in a NoSQL database like MongoDB, supporting flexible and dynamic data structures.</p>
<p><strong>Advantages</strong>: - Provides flexibility in handling varying data structures - Supports evolving schemas - Suitable for big data and NoSQL environments</p>
<p><strong>Disadvantages</strong>: - Can result in less efficient storage and retrieval compared to structured data - Potentially leads to challenges in ensuring data integrity and consistency</p>
<hr>
</section>
<section id="graph-data-modeling" class="level2">
<h2 class="anchored" data-anchor-id="graph-data-modeling">Graph Data Modeling</h2>
<p><strong>Definition</strong>: Graph data modeling involves designing schemas for data that is best represented as a graph, with entities as nodes and relationships as edges. This approach is ideal for capturing complex relationships and traversing interconnected data, commonly used in graph databases.</p>
<p><strong>Components</strong>: - <strong>Nodes</strong>: Represent entities or objects in the graph (e.g., people, products), each with properties (e.g., name, age, price).</p>
<ul>
<li><p><strong>Edges</strong>: Define relationships between nodes (e.g., friendships, purchases), each with properties and direction (e.g., start date, transaction amount).</p></li>
<li><p><strong>Properties</strong>: Capture attributes of nodes and edges, providing context and additional information (e.g., user age, transaction date).</p></li>
</ul>
<p><strong>Example</strong>: A social network graph with nodes for users and edges for friendships, where each user node has properties like name and age, and each friendship edge has properties like start date and relationship strength. This graph can be stored in a graph database like Neo4j, supporting efficient traversals and queries on relationships.</p>
<p><strong>Advantages</strong>: - Effectively captures complex relationships - Supports efficient traversals and queries on interconnected data - Suitable for use cases like social networks, recommendation systems, and fraud detection</p>
<p><strong>Disadvantages</strong>: - Can result in complex models with numerous nodes and edges - Requires specialized graph databases and query languages - Potentially impacts performance for large-scale graphs</p>
</section>
</section>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>