<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.47">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Ravi Shankar">

<title>generative_modeling_for_molecular_design – Data Down To Earth</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../logo.png" rel="icon" type="image/png">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../styles.css">
<link rel="stylesheet" href="../../content.css">
<meta property="og:title" content="– Data Down To Earth">
<meta property="og:site_name" content="Data Down To Earth">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Data Down To Earth</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-projects" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Projects</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-projects">    
        <li>
    <a class="dropdown-item" href="../../../projects/dsml_projects.html">
 <span class="dropdown-text">Data Science and ML Projects</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../projects/genai_projects.html">
 <span class="dropdown-text">Generative AI Projects</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-tutorials" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Tutorials</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-tutorials">    
        <li>
    <a class="dropdown-item" href="../../../topics/statistics.html">
 <span class="dropdown-text">Statistics &amp; Probability</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/machine_learning.html">
 <span class="dropdown-text">Machine Learning</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/de.html">
 <span class="dropdown-text">Data Engineering</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/generative_ai.html">
 <span class="dropdown-text">Generative AI</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/public_health.html">
 <span class="dropdown-text">Public Health</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/product_sense.html">
 <span class="dropdown-text">Product Sense</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../../notes/notes.html"> 
<span class="menu-text">Notes &amp; Research</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/iamrsps"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/iamravishankar/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content column-page" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
</div>



<div class="quarto-title-meta column-page">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Ravi Shankar </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<div class="text-content">
<section id="chapter-17-generative-modeling-for-molecular-design" class="level1">
<h1>Chapter 17: Generative Modeling For Molecular Design</h1>
</section>
<section id="chapter-17-generative-modeling-for-molecular-design-1" class="level1">
<h1>Chapter 17: Generative Modeling for Molecular Design</h1>
<section id="generative-modeling-for-molecular-design" class="level2">
<h2 class="anchored" data-anchor-id="generative-modeling-for-molecular-design">Generative Modeling for Molecular Design</h2>
<p>Generative modeling for molecular design leverages machine learning to create new molecules and chemical compounds with desired properties. This approach has significant applications in drug discovery, materials science, and chemical synthesis. Generative models can explore vast chemical spaces, predict properties of novel compounds, and suggest feasible synthetic routes.</p>
</section>
<section id="representing-molecules-and-chemical-compounds" class="level2">
<h2 class="anchored" data-anchor-id="representing-molecules-and-chemical-compounds">Representing Molecules and Chemical Compounds</h2>
<p>Molecules and chemical compounds can be represented in various ways for computational modeling, each with its advantages and limitations. The choice of representation can significantly impact the performance of generative models.</p>
<section id="smiles-simplified-molecular-input-line-entry-system" class="level3">
<h3 class="anchored" data-anchor-id="smiles-simplified-molecular-input-line-entry-system">1. SMILES (Simplified Molecular Input Line Entry System)</h3>
<p>SMILES is a text-based representation of chemical structures using short ASCII strings. It encodes molecules as sequences of characters, making it compatible with natural language processing techniques.</p>
<p><strong>Example</strong>: - Ethanol: <code>CCO</code> - Benzene: <code>c1ccccc1</code></p>
<section id="smiles-syntax" class="level4">
<h4 class="anchored" data-anchor-id="smiles-syntax">1.1 SMILES Syntax</h4>
<p>SMILES strings follow specific rules to represent molecular structures: - <strong>Atoms</strong>: Represented by their atomic symbols (e.g., <code>C</code> for carbon, <code>O</code> for oxygen). - <strong>Bonds</strong>: Single bonds are implied, while double (<code>=</code>) and triple (<code>#</code>) bonds are explicitly indicated. - <strong>Branches</strong>: Enclosed in parentheses to denote branching structures. - <strong>Rings</strong>: Denoted by numbers to indicate ring closures.</p>
</section>
</section>
<section id="molecular-graphs" class="level3">
<h3 class="anchored" data-anchor-id="molecular-graphs">2. Molecular Graphs</h3>
<p>Molecular graphs represent molecules as graphs where atoms are nodes, and bonds are edges. This representation captures the structural properties of molecules and is particularly suitable for graph-based machine learning methods.</p>
<p><strong>Example</strong>: - A carbon atom connected to two hydrogen atoms and one oxygen atom.</p>
<section id="graph-representation" class="level4">
<h4 class="anchored" data-anchor-id="graph-representation">2.1 Graph Representation</h4>
<p>A molecular graph <span class="math inline">\(G\)</span> can be represented as <span class="math inline">\(G = (V, E)\)</span> where: - <span class="math inline">\(V\)</span> is the set of nodes representing atoms. - <span class="math inline">\(E\)</span> is the set of edges representing bonds.</p>
<p>Each node <span class="math inline">\(v \in V\)</span> has a feature vector <span class="math inline">\(f(v)\)</span> encoding properties like atomic number and hybridization state. Each edge <span class="math inline">\(e \in E\)</span> has a feature vector <span class="math inline">\(f(e)\)</span> encoding bond type and order.</p>
</section>
</section>
<section id="molecular-fingerprints" class="level3">
<h3 class="anchored" data-anchor-id="molecular-fingerprints">3. Molecular Fingerprints</h3>
<p>Molecular fingerprints are binary vectors representing the presence or absence of specific substructures within a molecule. They are used for similarity searches and classification tasks.</p>
<p><strong>Example</strong>: - ECFP (Extended-Connectivity Fingerprints) - MACCS (Molecular ACCess System) keys</p>
<section id="ecfp-generation" class="level4">
<h4 class="anchored" data-anchor-id="ecfp-generation">3.1 ECFP Generation</h4>
<p>Extended-Connectivity Fingerprints (ECFPs) are generated by iteratively updating atom features based on their neighbors. The algorithm typically involves: 1. <strong>Initialization</strong>: Assigning initial identifiers to each atom based on their atomic properties. 2. <strong>Iteration</strong>: Updating atom identifiers by hashing the identifiers of neighboring atoms. 3. <strong>Finalization</strong>: Storing the resulting identifiers in a binary vector.</p>
</section>
</section>
<section id="d-conformers" class="level3">
<h3 class="anchored" data-anchor-id="d-conformers">4. 3D Conformers</h3>
<p>3D conformers represent the three-dimensional spatial arrangement of atoms in a molecule. This representation is important for capturing the stereochemistry and geometric properties of molecules.</p>
<p><strong>Example</strong>: - XYZ coordinates of atoms in a molecule.</p>
<section id="energy-minimization" class="level4">
<h4 class="anchored" data-anchor-id="energy-minimization">4.1 Energy Minimization</h4>
<p>3D conformers are often obtained through energy minimization techniques that optimize the molecular geometry to the lowest energy state. Methods like molecular dynamics (MD) simulations or quantum mechanical calculations are commonly used.</p>
</section>
</section>
</section>
<section id="generative-models-for-drug-discovery" class="level2">
<h2 class="anchored" data-anchor-id="generative-models-for-drug-discovery">Generative Models for Drug Discovery</h2>
<p>Generative models can design novel drug-like molecules by learning the underlying distribution of known compounds and generating new structures that fit this distribution. These models can be used to optimize properties such as bioactivity, solubility, and toxicity.</p>
<section id="molgan" class="level3">
<h3 class="anchored" data-anchor-id="molgan">MolGAN</h3>
<p>MolGAN is a generative adversarial network designed for generating molecular graphs. It combines GANs with reinforcement learning to optimize chemical properties.</p>
<section id="gan-architecture" class="level4">
<h4 class="anchored" data-anchor-id="gan-architecture">1. GAN Architecture</h4>
<p>MolGAN uses a generator <span class="math inline">\(G\)</span> and a discriminator <span class="math inline">\(D\)</span> to learn the distribution of molecular graphs.</p>
<p><strong>Generator (G)</strong>: Produces molecular graphs from random noise <span class="math inline">\(z\)</span>. <strong>Discriminator (D)</strong>: Differentiates between real and generated graphs.</p>
<p>The GAN is trained using the following objective:</p>
<p><span class="math display">\[
\min_G \max_D V(D, G) = \mathbb{E}_{x \sim p_{\text{data}}(x)}[\log D(x)] + \mathbb{E}_{z \sim p_z(z)}[\log(1 - D(G(z)))]
\]</span></p>
<p>Where: - <span class="math inline">\(p_{\text{data}}(x)\)</span> is the true data distribution. - <span class="math inline">\(p_z(z)\)</span> is the noise distribution. - <span class="math inline">\(G(z)\)</span> is the generator function. - <span class="math inline">\(D(x)\)</span> is the discriminator function.</p>
</section>
<section id="reinforcement-learning" class="level4">
<h4 class="anchored" data-anchor-id="reinforcement-learning">2. Reinforcement Learning</h4>
<p>MolGAN incorporates reinforcement learning to optimize specific chemical properties, such as solubility or bioactivity. The reward function <span class="math inline">\(R(x)\)</span> guides the generator towards producing molecules with desirable properties.</p>
<p>The generator’s parameters <span class="math inline">\(\theta_G\)</span> are updated to maximize the expected reward:</p>
<p><span class="math display">\[
\theta_G \leftarrow \theta_G + \alpha \nabla_{\theta_G} \mathbb{E}_{z \sim p_z(z)}[R(G(z))]
\]</span></p>
<p>Where <span class="math inline">\(\alpha\)</span> is the learning rate.</p>
</section>
</section>
<section id="jt-vae-junction-tree-variational-autoencoder" class="level3">
<h3 class="anchored" data-anchor-id="jt-vae-junction-tree-variational-autoencoder">JT-VAE (Junction Tree Variational Autoencoder)</h3>
<p>JT-VAE is a variational autoencoder designed to generate molecular graphs by decomposing molecules into tree-structured subgraphs.</p>
<section id="vae-architecture" class="level4">
<h4 class="anchored" data-anchor-id="vae-architecture">1. VAE Architecture</h4>
<p>JT-VAE includes an encoder <span class="math inline">\(E\)</span>, a decoder <span class="math inline">\(G\)</span>, and a junction tree processor.</p>
<p><strong>Encoder (E)</strong>: Encodes the molecular graph into a latent space. <strong>Decoder (G)</strong>: Reconstructs the molecular graph from the latent representation. <strong>Junction Tree Processor</strong>: Ensures that the generated graphs are chemically valid.</p>
<p>The VAE is trained using the following objective:</p>
<p><span class="math display">\[
\mathcal{L}_{\text{VAE}} = \mathbb{E}_{q_\phi(z|x)}[\log p_\theta(x|z)] - D_{KL}(q_\phi(z|x) \parallel p(z))
\]</span></p>
<p>Where: - <span class="math inline">\(q_\phi(z|x)\)</span> is the approximate posterior distribution. - <span class="math inline">\(p(z)\)</span> is the prior distribution. - <span class="math inline">\(\mathcal{L}_{\text{VAE}}\)</span> is the VAE loss.</p>
</section>
<section id="junction-tree-representation" class="level4">
<h4 class="anchored" data-anchor-id="junction-tree-representation">2. Junction Tree Representation</h4>
<p>The junction tree representation decomposes a molecule into substructures (e.g., rings, functional groups), which are then represented as a tree. This decomposition helps in capturing the hierarchical nature of molecular structures.</p>
</section>
</section>
<section id="graphaf-graph-autoregressive-flow" class="level3">
<h3 class="anchored" data-anchor-id="graphaf-graph-autoregressive-flow">GraphAF (Graph Autoregressive Flow)</h3>
<p>GraphAF is a generative model that uses autoregressive flows to generate molecular graphs. It combines the flexibility of normalizing flows with the sequential nature of autoregressive models.</p>
<section id="autoregressive-model" class="level4">
<h4 class="anchored" data-anchor-id="autoregressive-model">1. Autoregressive Model</h4>
<p>GraphAF generates molecules sequentially, adding one atom or bond at a time. The probability of each addition is modeled autoregressively:</p>
<p><span class="math display">\[
p(x) = \prod_{t=1}^T p(x_t | x_{1:t-1})
\]</span></p>
<p>Where: - <span class="math inline">\(x_t\)</span> is the addition at step <span class="math inline">\(t\)</span>. - <span class="math inline">\(x_{1:t-1}\)</span> are the previous additions.</p>
</section>
<section id="normalizing-flows" class="level4">
<h4 class="anchored" data-anchor-id="normalizing-flows">2. Normalizing Flows</h4>
<p>Normalizing flows transform a simple distribution (e.g., Gaussian) into a complex distribution using a series of invertible transformations:</p>
<p><span class="math display">\[
z = f(x)
\]</span></p>
<p>The likelihood of the data can be computed using the change of variables formula:</p>
<p><span class="math display">\[
p(x) = p(z) \left| \det \frac{\partial f^{-1}}{\partial x} \right|
\]</span></p>
<p>Where <span class="math inline">\(\left| \det \frac{\partial f^{-1}}{\partial x} \right|\)</span> is the determinant of the Jacobian of the inverse transformation.</p>
</section>
</section>
</section>
<section id="reinforcement-learning-for-molecular-optimization" class="level2">
<h2 class="anchored" data-anchor-id="reinforcement-learning-for-molecular-optimization">Reinforcement Learning for Molecular Optimization</h2>
<p>Reinforcement learning (RL) can be used to optimize molecules by treating the generation process as a sequential decision-making problem.</p>
<section id="rl-framework" class="level3">
<h3 class="anchored" data-anchor-id="rl-framework">1. RL Framework</h3>
<p>In the RL framework, the agent interacts with an environment by taking actions and receiving rewards. For molecular design:</p>
<ul>
<li><strong>State</strong>: Partial molecular structure.</li>
<li><strong>Action</strong>: Adding an atom or bond.</li>
<li><strong>Reward</strong>: Chemical property score (e.g., binding affinity, solubility).</li>
</ul>
</section>
<section id="policy-gradient-methods" class="level3">
<h3 class="anchored" data-anchor-id="policy-gradient-methods">2. Policy Gradient Methods</h3>
<p>Policy gradient methods optimize the policy directly by maximizing the expected reward:</p>
<p><span class="math display">\[
\nabla J(\theta) = \mathbb{E}_{\tau \sim \pi_\theta(\tau)} \left[ \sum_{t=1}^T \nabla_\theta \log \pi_\theta(a_t|s_t) R(\tau) \right]
\]</span></p>
<p>Where <span class="math inline">\(\pi_\theta(a_t|s_t)\)</span> is the policy, <span class="math inline">\(a_t\)</span> is the action at time <span class="math inline">\(t\)</span>, <span class="math inline">\(s_t\)</span> is the state at time <span class="math inline">\(t\)</span>, and <span class="math inline">\(R(\tau)\)</span> is the reward of trajectory <span class="math inline">\(\tau\)</span>.</p>
</section>
<section id="deep-q-networks-dqn" class="level3">
<h3 class="anchored" data-anchor-id="deep-q-networks-dqn">3. Deep Q-Networks (DQN)</h3>
<p>DQN learns a Q-function that estimates the expected reward of taking an action in a given state and following the optimal policy thereafter:</p>
<p><span class="math display">\[
Q(s, a) = \mathbb{E}[R_t | s_t = s, a_t = a]
\]</span></p>
<p>The Q-function is updated using the Bellman equation:</p>
<p><span class="math display">\[
Q(s, a) = r + \gamma \max_{a'} Q(s', a')
\]</span></p>
<p>Where <span class="math inline">\(r\)</span> is the reward, <span class="math inline">\(\gamma\)</span> is the discount factor, and <span class="math inline">\(s'\)</span> is the next state.</p>
</section>
</section>
<section id="generative-models-for-retrosynthesis-planning" class="level2">
<h2 class="anchored" data-anchor-id="generative-models-for-retrosynthesis-planning">Generative Models for Retrosynthesis Planning</h2>
<p>Retrosynthesis planning involves designing synthetic routes to produce a target molecule from available starting materials. Generative models can assist in this task by generating plausible reaction pathways.</p>
<section id="template-based-approaches" class="level3">
<h3 class="anchored" data-anchor-id="template-based-approaches">1. Template-Based Approaches</h3>
<p>Template-based approaches use reaction templates to predict the outcomes of chemical reactions. These templates encode known reaction rules and are used to propose potential transformations.</p>
</section>
<section id="template-free-approaches" class="level3">
<h3 class="anchored" data-anchor-id="template-free-approaches">2. Template-Free Approaches</h3>
<p>Template-free approaches use machine learning models to predict reaction outcomes without relying on predefined templates. These models learn to generate reactions directly from data.</p>
<section id="seq2seq-models" class="level4">
<h4 class="anchored" data-anchor-id="seq2seq-models">1. Seq2Seq Models</h4>
<p>Seq2Seq models generate reaction outcomes by treating the input molecules and products as sequences of tokens. The model learns to map reactant sequences to product sequences.</p>
<p><span class="math display">\[
p(y|x) = \prod_{t=1}^T p(y_t | y_{&lt;t}, x)
\]</span></p>
<p>Where <span class="math inline">\(y\)</span> is the product sequence and <span class="math inline">\(x\)</span> is the reactant sequence.</p>
</section>
<section id="graph-based-models" class="level4">
<h4 class="anchored" data-anchor-id="graph-based-models">2. Graph-Based Models</h4>
<p>Graph-based models represent molecules as graphs and use graph neural networks to predict reaction outcomes. These models can capture the structural relationships between atoms and bonds.</p>
<p><span class="math display">\[
h_v = \text{GNN}(G, v)
\]</span></p>
<p>Where <span class="math inline">\(h_v\)</span> is the node embedding for atom <span class="math inline">\(v\)</span> in graph <span class="math inline">\(G\)</span>.</p>
</section>
</section>
</section>
<section id="techniques-for-handling-chemical-constraints-and-properties" class="level2">
<h2 class="anchored" data-anchor-id="techniques-for-handling-chemical-constraints-and-properties">Techniques for Handling Chemical Constraints and Properties</h2>
<p>Designing molecules requires adherence to chemical constraints and the optimization of properties such as stability, solubility, and bioactivity.</p>
<section id="validity-constraints" class="level3">
<h3 class="anchored" data-anchor-id="validity-constraints">1. Validity Constraints</h3>
<p>Validity constraints ensure that generated molecules are chemically valid. This includes checking for: - Proper valence for each atom. - Valid bond configurations. - Absence of unphysical structures.</p>
</section>
<section id="property-prediction-models" class="level3">
<h3 class="anchored" data-anchor-id="property-prediction-models">2. Property Prediction Models</h3>
<p>Property prediction models estimate the properties of generated molecules, guiding the generation process towards desirable compounds.</p>
<section id="qsar-models" class="level4">
<h4 class="anchored" data-anchor-id="qsar-models">1. QSAR Models</h4>
<p>Quantitative Structure-Activity Relationship (QSAR) models predict the biological activity of molecules based on their chemical structure. These models use features derived from the molecular structure to predict properties such as toxicity, bioavailability, and efficacy.</p>
<p><span class="math display">\[
\text{Property} = f(\text{Molecular Features})
\]</span></p>
</section>
<section id="multi-objective-optimization" class="level4">
<h4 class="anchored" data-anchor-id="multi-objective-optimization">2. Multi-Objective Optimization</h4>
<p>Multi-objective optimization techniques balance multiple properties simultaneously. For example, optimizing both solubility and bioactivity:</p>
<p><span class="math display">\[
\text{Objective} = w_1 \cdot \text{Solubility} + w_2 \cdot \text{Bioactivity}
\]</span></p>
<p>Where <span class="math inline">\(w_1\)</span> and <span class="math inline">\(w_2\)</span> are weights reflecting the importance of each property.</p>
</section>
</section>
<section id="adversarial-training" class="level3">
<h3 class="anchored" data-anchor-id="adversarial-training">3. Adversarial Training</h3>
<p>Adversarial training can be used to improve the robustness and generalizability of generative models. This involves training a discriminator to distinguish between real and generated molecules, encouraging the generator to produce more realistic and diverse structures.</p>
</section>
<section id="transfer-learning" class="level3">
<h3 class="anchored" data-anchor-id="transfer-learning">4. Transfer Learning</h3>
<p>Transfer learning involves pre-training a generative model on a large dataset of molecules and fine-tuning it on a smaller, task-specific dataset. This approach leverages the knowledge gained from the large dataset to improve performance on the specific task.</p>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Generative modeling offers powerful tools for molecular design, enabling the creation of novel compounds with desired properties. By leveraging techniques such as GANs, VAEs, reinforcement learning, and retrosynthesis planning, these models can accelerate drug discovery and materials design. Advanced techniques for handling chemical constraints and properties further enhance the capabilities of generative models, making them indispensable tools in modern computational chemistry and molecular engineering.</p>
</section>
</section>
</div>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>