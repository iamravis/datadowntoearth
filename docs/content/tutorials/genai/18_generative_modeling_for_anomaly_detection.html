<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.47">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Ravi Shankar">

<title>generative_modeling_for_anomaly_detection – Data Down To Earth</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../logo.png" rel="icon" type="image/png">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../styles.css">
<link rel="stylesheet" href="../../content.css">
<meta property="og:title" content="– Data Down To Earth">
<meta property="og:description" content="">
<meta property="og:site_name" content="Data Down To Earth">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Data Down To Earth</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-projects" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Projects</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-projects">    
        <li>
    <a class="dropdown-item" href="../../../projects/dsml_projects.html">
 <span class="dropdown-text">Data Science and ML Projects</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../projects/genai_projects.html">
 <span class="dropdown-text">Generative AI Projects</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-tutorials" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Tutorials</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-tutorials">    
        <li>
    <a class="dropdown-item" href="../../../topics/statistics.html">
 <span class="dropdown-text">Statistics &amp; Probability</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/machine_learning.html">
 <span class="dropdown-text">Machine Learning</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/de.html">
 <span class="dropdown-text">Data Engineering</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/generative_ai.html">
 <span class="dropdown-text">Generative AI</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/public_health.html">
 <span class="dropdown-text">Public Health</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../topics/product_sense.html">
 <span class="dropdown-text">Product Sense</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../../notes/notes.html"> 
<span class="menu-text">Notes</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/iamrsps"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/iamravishankar/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content column-page" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
</div>



<div class="quarto-title-meta column-page">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Ravi Shankar </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="chapter-18-generative-modeling-for-anomaly-detection" class="level1 text-content">
<h1>Chapter 18: Generative Modeling For Anomaly Detection</h1>
<p>Generative models can be powerful tools for identifying outliers and anomalies in data. These models learn the underlying distribution of the data and can identify instances that deviate significantly from this distribution. Anomaly detection is crucial in various applications, such as fraud detection, network security, manufacturing quality control, and medical diagnosis.</p>
<section id="identifying-outliers-and-anomalies" class="level2">
<h2 class="anchored" data-anchor-id="identifying-outliers-and-anomalies">Identifying Outliers and Anomalies</h2>
<p>Outliers and anomalies are data points that differ significantly from the majority of the data. Detecting these points is essential for maintaining the integrity of datasets and for identifying unusual or unexpected events that could indicate errors, fraud, or novel phenomena.</p>
<section id="outliers" class="level3">
<h3 class="anchored" data-anchor-id="outliers">Outliers</h3>
<p>Outliers are individual data points that lie far from the main distribution of the data. They can result from measurement errors, experimental errors, or natural variability. Identifying outliers is crucial for cleaning data and ensuring the accuracy of statistical analyses and machine learning models.</p>
</section>
<section id="anomalies" class="level3">
<h3 class="anchored" data-anchor-id="anomalies">Anomalies</h3>
<p>Anomalies are patterns in data that do not conform to expected behavior. They can indicate novel or unexpected events, such as fraud, network intrusions, structural defects, or rare medical conditions. Detecting anomalies can help in early warning systems and in identifying new phenomena.</p>
</section>
</section>
<section id="generative-adversarial-networks-for-anomaly-detection" class="level2">
<h2 class="anchored" data-anchor-id="generative-adversarial-networks-for-anomaly-detection">Generative Adversarial Networks for Anomaly Detection</h2>
<p>Generative Adversarial Networks (GANs) can be adapted for anomaly detection by learning to generate realistic data samples. Anomalies are detected based on their reconstruction error or the discriminator’s response.</p>
<section id="anogan" class="level3">
<h3 class="anchored" data-anchor-id="anogan">AnoGAN</h3>
<p>AnoGAN is an early approach that uses GANs for anomaly detection. It trains a GAN on normal data and uses the generator to identify anomalies.</p>
<section id="gan-architecture" class="level4">
<h4 class="anchored" data-anchor-id="gan-architecture">1. GAN Architecture</h4>
<p>AnoGAN uses a standard GAN architecture, consisting of a generator ( G ) and a discriminator ( D ):</p>
<ul>
<li><strong>Generator (G)</strong>: Learns to generate realistic data samples from random noise ( z ).</li>
<li><strong>Discriminator (D)</strong>: Learns to distinguish between real data samples and generated samples.</li>
</ul>
<p>The GAN is trained using the following minimax game:</p>
<p><span class="math display">\[
\min_G \max_D V(D, G) = \mathbb{E}_{x \sim p_{\text{data}}(x)}[\log D(x)] + \mathbb{E}_{z \sim p_z(z)}[\log(1 - D(G(z)))]
\]</span></p>
<p>Where: - ( p_{}(x) ) is the true data distribution. - ( p_z(z) ) is the prior distribution of the input noise. - ( G(z) ) is the generator function. - ( D(x) ) is the discriminator function.</p>
</section>
<section id="anomaly-detection" class="level4">
<h4 class="anchored" data-anchor-id="anomaly-detection">2. Anomaly Detection</h4>
<p>After training, AnoGAN uses the generator to find the latent variable ( z ) that best reconstructs a given data sample ( x ). This is achieved by minimizing the reconstruction error:</p>
<p><span class="math display">\[
z^* = \arg\min_z \| x - G(z) \|_2
\]</span></p>
<p>The anomaly score is computed as a combination of the reconstruction error and the discriminator’s output:</p>
<p><span class="math display">\[
A(x) = \lambda \| x - G(z^*) \|_2 + (1 - \lambda) (1 - D(G(z^*)))
\]</span></p>
<p>Where ( ) is a weighting factor that balances the contributions of the reconstruction error and the discriminator’s output to the anomaly score.</p>
</section>
</section>
<section id="adgan" class="level3">
<h3 class="anchored" data-anchor-id="adgan">ADGAN</h3>
<p>ADGAN (Adversarially Learned Anomaly Detection) improves on AnoGAN by using an encoder-decoder architecture. It directly learns a mapping from data to the latent space, making the anomaly detection process more efficient.</p>
<section id="architecture" class="level4">
<h4 class="anchored" data-anchor-id="architecture">1. Architecture</h4>
<p>ADGAN includes three components: - <strong>Encoder (E)</strong>: Maps data samples to the latent space. - <strong>Generator (G)</strong>: Generates data samples from latent vectors. - <strong>Discriminator (D)</strong>: Distinguishes between real and generated samples.</p>
<p>The encoder ( E ) learns to compress data ( x ) into a latent representation ( z ), the generator ( G ) learns to decode ( z ) back to the data space, and the discriminator ( D ) learns to differentiate between real data ( x ) and generated data ( G(z) ).</p>
</section>
<section id="training-objective" class="level4">
<h4 class="anchored" data-anchor-id="training-objective">2. Training Objective</h4>
<p>The training objective includes both reconstruction and adversarial losses:</p>
<p><span class="math display">\[
\mathcal{L}_\text{recon} = \mathbb{E}_{x \sim p_{\text{data}}(x)} \| x - G(E(x)) \|_2^2
\]</span></p>
<p><span class="math display">\[
\mathcal{L}_\text{adv} = \mathbb{E}_{x \sim p_{\text{data}}(x)}[\log D(x)] + \mathbb{E}_{z \sim p_z(z)}[\log(1 - D(G(z)))]
\]</span></p>
<p>The total loss is a combination of these two terms:</p>
<p><span class="math display">\[
\mathcal{L} = \mathcal{L}_\text{recon} + \lambda \mathcal{L}_\text{adv}
\]</span></p>
<p>Where ( ) is a hyperparameter balancing the two losses.</p>
</section>
<section id="anomaly-detection-1" class="level4">
<h4 class="anchored" data-anchor-id="anomaly-detection-1">3. Anomaly Detection</h4>
<p>Anomaly detection is performed by computing the reconstruction error:</p>
<p><span class="math display">\[
A(x) = \| x - G(E(x)) \|_2
\]</span></p>
<p>Samples with high reconstruction error are considered anomalies. The assumption is that normal samples will have lower reconstruction errors because they lie closer to the learned data distribution, while anomalies will have higher errors.</p>
</section>
</section>
</section>
<section id="variational-autoencoders-for-anomaly-detection" class="level2">
<h2 class="anchored" data-anchor-id="variational-autoencoders-for-anomaly-detection">Variational Autoencoders for Anomaly Detection</h2>
<p>Variational Autoencoders (VAEs) are another class of generative models used for anomaly detection. They learn a probabilistic model of the data and can identify anomalies based on the likelihood of data samples.</p>
<section id="dagmm-deep-autoencoding-gaussian-mixture-model" class="level3">
<h3 class="anchored" data-anchor-id="dagmm-deep-autoencoding-gaussian-mixture-model">DAGMM (Deep Autoencoding Gaussian Mixture Model)</h3>
<p>DAGMM combines autoencoders with Gaussian Mixture Models (GMMs) for anomaly detection. It learns a low-dimensional representation of the data and models this representation using a GMM.</p>
<section id="architecture-1" class="level4">
<h4 class="anchored" data-anchor-id="architecture-1">1. Architecture</h4>
<p>DAGMM consists of two main components: - <strong>Autoencoder (AE)</strong>: Reduces the dimensionality of the data. - <strong>GMM</strong>: Models the low-dimensional representations.</p>
<p>The autoencoder maps the data ( x ) to a low-dimensional representation ( z ):</p>
<p><span class="math display">\[
z = E(x)
\]</span></p>
<p>The reconstruction is given by ( = G(z) ).</p>
</section>
<section id="training-objective-1" class="level4">
<h4 class="anchored" data-anchor-id="training-objective-1">2. Training Objective</h4>
<p>The autoencoder is trained to minimize the reconstruction error:</p>
<p><span class="math display">\[
\mathcal{L}_\text{recon} = \mathbb{E}_{x \sim p_{\text{data}}(x)} \| x - \hat{x} \|_2^2
\]</span></p>
<p>The GMM is trained to model the distribution of ( z ):</p>
<p><span class="math display">\[
p(z) = \sum_{k=1}^{K} \pi_k \mathcal{N}(z; \mu_k, \Sigma_k)
\]</span></p>
<p>Where ( _k ), ( _k ), and ( _k ) are the mixture weights, means, and covariances of the GMM components.</p>
</section>
<section id="anomaly-detection-2" class="level4">
<h4 class="anchored" data-anchor-id="anomaly-detection-2">3. Anomaly Detection</h4>
<p>Anomaly detection is performed using the energy score, which combines the reconstruction error and the GMM likelihood:</p>
<p><span class="math display">\[
A(x) = \mathcal{E}(x) = \| x - \hat{x} \|_2 + \gamma \log \sum_{k=1}^{K} \pi_k \mathcal{N}(z; \mu_k, \Sigma_k)
\]</span></p>
<p>Where ( ) is a weighting factor. The energy score measures how well a data point fits the learned model, with higher scores indicating anomalies.</p>
</section>
</section>
<section id="cavga-convolutional-adversarial-variational-gaussian-autoencoder" class="level3">
<h3 class="anchored" data-anchor-id="cavga-convolutional-adversarial-variational-gaussian-autoencoder">CAVGA (Convolutional Adversarial Variational Gaussian Autoencoder)</h3>
<p>CAVGA is a variant of VAE that incorporates adversarial training and Gaussian priors for anomaly detection.</p>
<section id="architecture-2" class="level4">
<h4 class="anchored" data-anchor-id="architecture-2">1. Architecture</h4>
<p>CAVGA includes: - <strong>Encoder (E)</strong>: Maps data samples to latent variables. - <strong>Decoder (G)</strong>: Reconstructs data samples from latent variables. - <strong>Discriminator (D)</strong>: Distinguishes between real and generated data samples.</p>
</section>
<section id="training-objective-2" class="level4">
<h4 class="anchored" data-anchor-id="training-objective-2">2. Training Objective</h4>
<p>The VAE loss includes a reconstruction term and a Kullback-Leibler divergence term:</p>
<p><span class="math display">\[
\mathcal{L}_\text{VAE} = \mathbb{E}_{q_\phi(z|x)}[\log p_\theta(x|z)] - D_{KL}(q_\phi(z|x) \parallel p(z))
\]</span></p>
<p>Where ( q_(z|x) ) is the approximate posterior and ( p(z) ) is the prior distribution.</p>
<p>The adversarial loss encourages the discriminator to distinguish between real and generated samples:</p>
<p><span class="math display">\[
\mathcal{L}_\text{adv} = \mathbb{E}_{x \sim p_{\text{data}}(x)}[\log D(x)] + \mathbb{E}_{z \sim p_z(z)}[\log(1 - D(G(z)))]
\]</span></p>
<p>The total loss is:</p>
<p><span class="math display">\[
\mathcal{L} = \mathcal{L}_\text{VAE} + \lambda \mathcal{L}_\text{adv}
\]</span></p>
<p>Where ( ) is a hyperparameter balancing the two losses.</p>
</section>
<section id="anomaly-detection-3" class="level4">
<h4 class="anchored" data-anchor-id="anomaly-detection-3">3. Anomaly Detection</h4>
<p>Anomaly detection is based on the reconstruction error and the discriminator’s output:</p>
<p><span class="math display">\[
A(x) = \| x - G(E(x)) \|_2 + (1 - D(G(E(x))))
\]</span></p>
<p>The combination of the reconstruction error and the discriminator’s output helps to identify anomalies more effectively.</p>
</section>
</section>
</section>
<section id="one-class-classification-and-isolation-forests" class="level2">
<h2 class="anchored" data-anchor-id="one-class-classification-and-isolation-forests">One-Class Classification and Isolation Forests</h2>
<p>One-class classification methods and isolation forests are traditional techniques for anomaly detection.</p>
<section id="one-class-svm" class="level3">
<h3 class="anchored" data-anchor-id="one-class-svm">One-Class SVM</h3>
<p>One-Class SVM aims to separate normal data from anomalies by learning a decision boundary that encompasses most of the data.</p>
<section id="objective" class="level4">
<h4 class="anchored" data-anchor-id="objective">1. Objective</h4>
<p>The objective is to minimize the volume of a hypersphere that encloses the normal data points:</p>
<p><span class="math display">\[
\min \frac{1}{2} \| w \|^2 + \frac{1}{\nu N} \sum_{i=1}^N \max(0, \rho - (w \cdot x_i - b))
\]</span></p>
<p>Where ( ) is a parameter controlling the trade-off between the volume of the hypersphere and the number of training errors. Here, ( w ) is the weight vector, ( b ) is the bias term, ( ) is the offset, and ( x_i ) represents the data points.</p>
</section>
<section id="anomaly-detection-4" class="level4">
<h4 class="anchored" data-anchor-id="anomaly-detection-4">2. Anomaly Detection</h4>
<p>Anomaly detection is performed by checking if new data points fall outside the decision boundary:</p>
<p><span class="math display">\[
A(x) = \begin{cases}
      0 &amp; \text{if } w \cdot x - b \geq \rho \\
      1 &amp; \text{if } w \cdot x - b &lt; \rho
   \end{cases}
\]</span></p>
<p>Data points that lie outside the decision boundary are classified as anomalies.</p>
</section>
</section>
<section id="isolation-forest" class="level3">
<h3 class="anchored" data-anchor-id="isolation-forest">Isolation Forest</h3>
<p>Isolation Forests isolate anomalies by recursively partitioning the data.</p>
<section id="algorithm" class="level4">
<h4 class="anchored" data-anchor-id="algorithm">1. Algorithm</h4>
<p>The algorithm builds an ensemble of trees, where each tree isolates a subset of data points:</p>
<ol type="1">
<li>Randomly select a feature.</li>
<li>Randomly select a split value for the feature.</li>
<li>Partition the data based on the split value.</li>
<li>Repeat until each data point is isolated or the tree reaches a specified depth.</li>
</ol>
</section>
<section id="anomaly-score" class="level4">
<h4 class="anchored" data-anchor-id="anomaly-score">2. Anomaly Score</h4>
<p>The anomaly score is based on the path length ( h(x) ) of a data point ( x ):</p>
<p><span class="math display">\[
s(x) = 2^{-\frac{E(h(x))}{c(n)}}
\]</span></p>
<p>Where ( E(h(x)) ) is the average path length of ( x ) in the trees, and ( c(n) ) is a normalization factor that depends on the number of data points ( n ). The shorter the path length, the more likely it is that the data point is an anomaly.</p>
</section>
</section>
</section>
<section id="techniques-for-handling-high-dimensional-and-complex-data" class="level2">
<h2 class="anchored" data-anchor-id="techniques-for-handling-high-dimensional-and-complex-data">Techniques for Handling High-Dimensional and Complex Data</h2>
<p>Anomaly detection in high-dimensional and complex data requires specialized techniques to address the challenges of sparsity and computational complexity.</p>
<section id="dimensionality-reduction" class="level3">
<h3 class="anchored" data-anchor-id="dimensionality-reduction">Dimensionality Reduction</h3>
<p>Dimensionality reduction techniques, such as PCA and t-SNE, can be used to project high-dimensional data into a lower-dimensional space, making it easier to visualize and analyze.</p>
<section id="principal-component-analysis-pca" class="level4">
<h4 class="anchored" data-anchor-id="principal-component-analysis-pca">Principal Component Analysis (PCA)</h4>
<p>PCA projects the data onto the directions of maximum variance:</p>
<p><span class="math display">\[
Z = XW
\]</span></p>
<p>Where ( W ) is the matrix of eigenvectors of the covariance matrix of ( X ). The eigenvectors correspond to the principal components, and the eigenvalues indicate the amount of variance captured by each principal component.</p>
</section>
<section id="t-sne" class="level4">
<h4 class="anchored" data-anchor-id="t-sne">t-SNE</h4>
<p>t-SNE is a non-linear dimensionality reduction technique that minimizes the Kullback-Leibler divergence between high-dimensional and low-dimensional distributions:</p>
<p><span class="math display">\[
KL(P \parallel Q) = \sum_{i \ne j} p_{ij} \log \frac{p_{ij}}{q_{ij}}
\]</span></p>
<p>Where ( p_{ij} ) and ( q_{ij} ) are the similarities between data points in the high-dimensional and low-dimensional spaces, respectively. t-SNE converts the distances between data points into probabilities and tries to preserve the structure of the data in the lower-dimensional space.</p>
</section>
</section>
<section id="feature-engineering" class="level3">
<h3 class="anchored" data-anchor-id="feature-engineering">Feature Engineering</h3>
<p>Feature engineering involves creating new features that capture the important characteristics of the data. This process can significantly improve the performance of anomaly detection models.</p>
<section id="techniques" class="level4">
<h4 class="anchored" data-anchor-id="techniques">Techniques</h4>
<ul>
<li><strong>Normalization</strong>: Scaling features to a common range to ensure that all features contribute equally to the model. This can be done using techniques such as min-max scaling or z-score normalization.</li>
<li><strong>Encoding Categorical Variables</strong>: Converting categorical variables to numerical values using techniques such as one-hot encoding or embedding. One-hot encoding creates binary features for each category, while embedding maps categories to dense vectors.</li>
<li><strong>Generating Interaction Terms</strong>: Creating new features by combining existing features. For example, interaction terms can capture the combined effect of two features on the target variable.</li>
</ul>
</section>
</section>
<section id="ensemble-methods" class="level3">
<h3 class="anchored" data-anchor-id="ensemble-methods">Ensemble Methods</h3>
<p>Ensemble methods combine multiple models to improve robustness and accuracy. They leverage the strengths of different models to achieve better performance than any single model.</p>
<section id="techniques-1" class="level4">
<h4 class="anchored" data-anchor-id="techniques-1">Techniques</h4>
<ul>
<li><strong>Bagging</strong>: Training multiple models on different subsets of the data and averaging their predictions. This reduces variance and helps prevent overfitting.</li>
<li><strong>Boosting</strong>: Sequentially training models to correct the errors of previous models. Each model focuses on the samples that were misclassified by the previous models, improving overall accuracy.</li>
<li><strong>Stacking</strong>: Combining the predictions of multiple models using a meta-model. The meta-model learns to make better predictions by leveraging the outputs of base models.</li>
</ul>
</section>
</section>
<section id="advanced-neural-network-architectures" class="level3">
<h3 class="anchored" data-anchor-id="advanced-neural-network-architectures">Advanced Neural Network Architectures</h3>
<p>Advanced neural network architectures, such as attention mechanisms and recurrent networks, can capture complex dependencies in the data.</p>
<section id="attention-mechanisms" class="level4">
<h4 class="anchored" data-anchor-id="attention-mechanisms">Attention Mechanisms</h4>
<p>Attention mechanisms allow the model to focus on relevant parts of the input:</p>
<p><span class="math display">\[
\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V
\]</span></p>
<p>Where ( Q ), ( K ), and ( V ) are query, key, and value matrices. The attention mechanism computes a weighted sum of the values, where the weights are determined by the similarity between the queries and keys.</p>
</section>
<section id="recurrent-networks" class="level4">
<h4 class="anchored" data-anchor-id="recurrent-networks">Recurrent Networks</h4>
<p>Recurrent networks, such as LSTMs and GRUs, can capture temporal dependencies in sequential data:</p>
<p><span class="math display">\[
h_t = f(W_x x_t + W_h h_{t-1} + b)
\]</span></p>
<p>Where ( h_t ) is the hidden state at time ( t ), ( x_t ) is the input at time ( t ), ( W_x ) and ( W_h ) are weight matrices, and ( b ) is the bias term. LSTMs and GRUs include gating mechanisms that help capture long-term dependencies and mitigate the vanishing gradient problem.</p>
</section>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Generative modeling offers powerful techniques for anomaly detection by learning the underlying distribution of the data and identifying deviations from this distribution. By leveraging methods such as GANs, VAEs, one-class classification, and isolation forests, these models can effectively detect anomalies in various applications. Advanced techniques for handling high-dimensional and complex data further enhance the capabilities of generative models for anomaly detection. As research continues to advance, these models will become increasingly effective at identifying and understanding anomalies in diverse datasets.</p>
</section>
</section>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>